
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/spiffe/spike/app/demo/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/spiffe/spike/app/keeper/cmd/main.go (0.0%)</option>
				
				<option value="file2">github.com/spiffe/spike/app/keeper/internal/env/out.go (0.0%)</option>
				
				<option value="file3">github.com/spiffe/spike/app/keeper/internal/env/spiffe.go (0.0%)</option>
				
				<option value="file4">github.com/spiffe/spike/app/keeper/internal/env/tls.go (100.0%)</option>
				
				<option value="file5">github.com/spiffe/spike/app/keeper/internal/net/serve.go (0.0%)</option>
				
				<option value="file6">github.com/spiffe/spike/app/keeper/internal/route/base/route.go (0.0%)</option>
				
				<option value="file7">github.com/spiffe/spike/app/keeper/internal/route/store/contribute.go (0.0%)</option>
				
				<option value="file8">github.com/spiffe/spike/app/keeper/internal/route/store/shard.go (0.0%)</option>
				
				<option value="file9">github.com/spiffe/spike/app/keeper/internal/state/shard.go (0.0%)</option>
				
				<option value="file10">github.com/spiffe/spike/app/nexus/cmd/main.go (0.0%)</option>
				
				<option value="file11">github.com/spiffe/spike/app/nexus/internal/env/backend.go (0.0%)</option>
				
				<option value="file12">github.com/spiffe/spike/app/nexus/internal/env/database.go (0.0%)</option>
				
				<option value="file13">github.com/spiffe/spike/app/nexus/internal/env/keeper.go (0.0%)</option>
				
				<option value="file14">github.com/spiffe/spike/app/nexus/internal/env/net.go (0.0%)</option>
				
				<option value="file15">github.com/spiffe/spike/app/nexus/internal/env/out.go (0.0%)</option>
				
				<option value="file16">github.com/spiffe/spike/app/nexus/internal/env/recovery.go (0.0%)</option>
				
				<option value="file17">github.com/spiffe/spike/app/nexus/internal/env/secret.go (0.0%)</option>
				
				<option value="file18">github.com/spiffe/spike/app/nexus/internal/env/shamir.go (0.0%)</option>
				
				<option value="file19">github.com/spiffe/spike/app/nexus/internal/env/spiffe.go (0.0%)</option>
				
				<option value="file20">github.com/spiffe/spike/app/nexus/internal/initialization/bootstrap.go (0.0%)</option>
				
				<option value="file21">github.com/spiffe/spike/app/nexus/internal/initialization/initialization.go (0.0%)</option>
				
				<option value="file22">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/keeper.go (0.0%)</option>
				
				<option value="file23">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/recovery.go (0.0%)</option>
				
				<option value="file24">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/root_key.go (0.0%)</option>
				
				<option value="file25">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/shamir.go (0.0%)</option>
				
				<option value="file26">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/shard.go (0.0%)</option>
				
				<option value="file27">github.com/spiffe/spike/app/nexus/internal/initialization/recovery/update.go (0.0%)</option>
				
				<option value="file28">github.com/spiffe/spike/app/nexus/internal/net/serve.go (0.0%)</option>
				
				<option value="file29">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/create.go (0.0%)</option>
				
				<option value="file30">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/create_intercept.go (0.0%)</option>
				
				<option value="file31">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/delete.go (0.0%)</option>
				
				<option value="file32">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/delete_intercept.go (0.0%)</option>
				
				<option value="file33">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/list.go (0.0%)</option>
				
				<option value="file34">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/list_intercept.go (0.0%)</option>
				
				<option value="file35">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/read.go (0.0%)</option>
				
				<option value="file36">github.com/spiffe/spike/app/nexus/internal/route/acl/policy/read_intercept.go (0.0%)</option>
				
				<option value="file37">github.com/spiffe/spike/app/nexus/internal/route/base/route.go (0.0%)</option>
				
				<option value="file38">github.com/spiffe/spike/app/nexus/internal/route/operator/recover.go (0.0%)</option>
				
				<option value="file39">github.com/spiffe/spike/app/nexus/internal/route/operator/recover_intercept.go (0.0%)</option>
				
				<option value="file40">github.com/spiffe/spike/app/nexus/internal/route/operator/restore.go (0.0%)</option>
				
				<option value="file41">github.com/spiffe/spike/app/nexus/internal/route/operator/restore_intercept.go (0.0%)</option>
				
				<option value="file42">github.com/spiffe/spike/app/nexus/internal/route/secret/delete.go (0.0%)</option>
				
				<option value="file43">github.com/spiffe/spike/app/nexus/internal/route/secret/delete_intercept.go (0.0%)</option>
				
				<option value="file44">github.com/spiffe/spike/app/nexus/internal/route/secret/errors.go (0.0%)</option>
				
				<option value="file45">github.com/spiffe/spike/app/nexus/internal/route/secret/get.go (0.0%)</option>
				
				<option value="file46">github.com/spiffe/spike/app/nexus/internal/route/secret/get_intercept.go (0.0%)</option>
				
				<option value="file47">github.com/spiffe/spike/app/nexus/internal/route/secret/list.go (0.0%)</option>
				
				<option value="file48">github.com/spiffe/spike/app/nexus/internal/route/secret/list_intercept.go (0.0%)</option>
				
				<option value="file49">github.com/spiffe/spike/app/nexus/internal/route/secret/map.go (0.0%)</option>
				
				<option value="file50">github.com/spiffe/spike/app/nexus/internal/route/secret/metadata_get.go (0.0%)</option>
				
				<option value="file51">github.com/spiffe/spike/app/nexus/internal/route/secret/metadata_get_intercept.go (0.0%)</option>
				
				<option value="file52">github.com/spiffe/spike/app/nexus/internal/route/secret/put.go (0.0%)</option>
				
				<option value="file53">github.com/spiffe/spike/app/nexus/internal/route/secret/put_intercept.go (0.0%)</option>
				
				<option value="file54">github.com/spiffe/spike/app/nexus/internal/route/secret/undelete.go (0.0%)</option>
				
				<option value="file55">github.com/spiffe/spike/app/nexus/internal/route/secret/undelete_intercept.go (0.0%)</option>
				
				<option value="file56">github.com/spiffe/spike/app/nexus/internal/state/backend/memory/memory.go (0.0%)</option>
				
				<option value="file57">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/construct.go (0.0%)</option>
				
				<option value="file58">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/crypto.go (0.0%)</option>
				
				<option value="file59">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/initialize.go (0.0%)</option>
				
				<option value="file60">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/options.go (0.0%)</option>
				
				<option value="file61">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/parse.go (0.0%)</option>
				
				<option value="file62">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/policy.go (0.0%)</option>
				
				<option value="file63">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/schema.go (0.0%)</option>
				
				<option value="file64">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/secret.go (0.0%)</option>
				
				<option value="file65">github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist/secret_load.go (0.0%)</option>
				
				<option value="file66">github.com/spiffe/spike/app/nexus/internal/state/base/data.go (0.0%)</option>
				
				<option value="file67">github.com/spiffe/spike/app/nexus/internal/state/base/init.go (0.0%)</option>
				
				<option value="file68">github.com/spiffe/spike/app/nexus/internal/state/base/path.go (0.0%)</option>
				
				<option value="file69">github.com/spiffe/spike/app/nexus/internal/state/base/policy.go (0.0%)</option>
				
				<option value="file70">github.com/spiffe/spike/app/nexus/internal/state/base/secret.go (14.3%)</option>
				
				<option value="file71">github.com/spiffe/spike/app/nexus/internal/state/base/validation.go (0.0%)</option>
				
				<option value="file72">github.com/spiffe/spike/app/nexus/internal/state/persist/backend.go (0.0%)</option>
				
				<option value="file73">github.com/spiffe/spike/app/nexus/internal/state/persist/init.go (0.0%)</option>
				
				<option value="file74">github.com/spiffe/spike/app/nexus/internal/state/persist/policy.go (0.0%)</option>
				
				<option value="file75">github.com/spiffe/spike/app/nexus/internal/state/persist/secret.go (0.0%)</option>
				
				<option value="file76">github.com/spiffe/spike/app/spike/cmd/main.go (0.0%)</option>
				
				<option value="file77">github.com/spiffe/spike/app/spike/internal/cmd/cmd.go (0.0%)</option>
				
				<option value="file78">github.com/spiffe/spike/app/spike/internal/cmd/operator/new.go (0.0%)</option>
				
				<option value="file79">github.com/spiffe/spike/app/spike/internal/cmd/operator/recover.go (0.0%)</option>
				
				<option value="file80">github.com/spiffe/spike/app/spike/internal/cmd/operator/restore.go (0.0%)</option>
				
				<option value="file81">github.com/spiffe/spike/app/spike/internal/cmd/policy/create.go (0.0%)</option>
				
				<option value="file82">github.com/spiffe/spike/app/spike/internal/cmd/policy/delete.go (0.0%)</option>
				
				<option value="file83">github.com/spiffe/spike/app/spike/internal/cmd/policy/error.go (0.0%)</option>
				
				<option value="file84">github.com/spiffe/spike/app/spike/internal/cmd/policy/filter.go (0.0%)</option>
				
				<option value="file85">github.com/spiffe/spike/app/spike/internal/cmd/policy/flag.go (0.0%)</option>
				
				<option value="file86">github.com/spiffe/spike/app/spike/internal/cmd/policy/fotmat.go (0.0%)</option>
				
				<option value="file87">github.com/spiffe/spike/app/spike/internal/cmd/policy/get.go (0.0%)</option>
				
				<option value="file88">github.com/spiffe/spike/app/spike/internal/cmd/policy/list.go (0.0%)</option>
				
				<option value="file89">github.com/spiffe/spike/app/spike/internal/cmd/policy/new.go (0.0%)</option>
				
				<option value="file90">github.com/spiffe/spike/app/spike/internal/cmd/policy/validation.go (0.0%)</option>
				
				<option value="file91">github.com/spiffe/spike/app/spike/internal/cmd/secret/delete.go (0.0%)</option>
				
				<option value="file92">github.com/spiffe/spike/app/spike/internal/cmd/secret/get.go (0.0%)</option>
				
				<option value="file93">github.com/spiffe/spike/app/spike/internal/cmd/secret/list.go (0.0%)</option>
				
				<option value="file94">github.com/spiffe/spike/app/spike/internal/cmd/secret/metadata_get.go (0.0%)</option>
				
				<option value="file95">github.com/spiffe/spike/app/spike/internal/cmd/secret/new.go (0.0%)</option>
				
				<option value="file96">github.com/spiffe/spike/app/spike/internal/cmd/secret/print.go (0.0%)</option>
				
				<option value="file97">github.com/spiffe/spike/app/spike/internal/cmd/secret/put.go (0.0%)</option>
				
				<option value="file98">github.com/spiffe/spike/app/spike/internal/cmd/secret/undelete.go (0.0%)</option>
				
				<option value="file99">github.com/spiffe/spike/app/spike/internal/env/env.go (0.0%)</option>
				
				<option value="file100">github.com/spiffe/spike/app/spike/internal/env/out.go (0.0%)</option>
				
				<option value="file101">github.com/spiffe/spike/app/spike/internal/stdout/stdout.go (0.0%)</option>
				
				<option value="file102">github.com/spiffe/spike/app/spike/internal/trust/spiffeid.go (0.0%)</option>
				
				<option value="file103">github.com/spiffe/spike/ci/test/main.go (0.0%)</option>
				
				<option value="file104">github.com/spiffe/spike/internal/config/config.go (0.0%)</option>
				
				<option value="file105">github.com/spiffe/spike/internal/log/audit.go (0.0%)</option>
				
				<option value="file106">github.com/spiffe/spike/internal/log/log.go (0.0%)</option>
				
				<option value="file107">github.com/spiffe/spike/internal/net/factory.go (0.0%)</option>
				
				<option value="file108">github.com/spiffe/spike/internal/net/handle.go (0.0%)</option>
				
				<option value="file109">github.com/spiffe/spike/internal/net/post.go (0.0%)</option>
				
				<option value="file110">github.com/spiffe/spike/internal/net/request.go (0.0%)</option>
				
				<option value="file111">github.com/spiffe/spike/internal/net/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package main

import (
        "fmt"

        spike "github.com/spiffe/spike-sdk-go/api"
)

func main() <span class="cov0" title="0">{
        // https://pkg.go.dev/github.com/spiffe/spike-sdk-go/api#New
        api := spike.New() // Use the default Workload API Socket

        // https://pkg.go.dev/github.com/spiffe/spike-sdk-go/api#Close
        defer api.Close() // Close the connection when done

        path := "tenants/demo/db/creds"

        // Create a Secret
        // https://pkg.go.dev/github.com/spiffe/spike-sdk-go/api#PutSecret
        err := api.PutSecret(path, map[string]string{
                "username": "SPIKE",
                "password": "SPIKE_Rocks",
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error writing secret:", err.Error())
                return
        }</span>

        // Read the Secret
        // https://pkg.go.dev/github.com/spiffe/spike-sdk-go/api#GetSecret
        <span class="cov0" title="0">secret, err := api.GetSecret(path)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error reading secret:", err.Error())
                return
        }</span>

        <span class="cov0" title="0">if secret == nil </span><span class="cov0" title="0">{
                fmt.Println("Secret not found.")
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Secret found:")

        data := secret.Data
        for k, v := range data </span><span class="cov0" title="0">{
                fmt.Printf("%s: %s\n", k, v)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package main

import (
        "context"
        "fmt"

        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/keeper/internal/env"
        "github.com/spiffe/spike/app/keeper/internal/net"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

const appName = "SPIKE Keeper"

func main() <span class="cov0" title="0">{
        if env.BannerEnabled() </span><span class="cov0" title="0">{
                fmt.Printf(`
   \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
 \\\\\ Copyright 2024-present SPIKE contributors.
\\\\\\\ SPDX-License-Identifier: Apache-2.0`+"\n\n"+
                        "%s v%s. | LOG LEVEL: %s\n\n",
                        appName, config.SpikeKeeperVersion, log.Level(),
                )
        }</span>

        <span class="cov0" title="0">if mem.Lock() </span><span class="cov0" title="0">{
                log.Log().Info(appName, "msg", "Successfully locked memory.")
        }</span> else<span class="cov0" title="0"> {
                log.Log().Info(appName, "msg", "Memory is not locked. Please disable swap.")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        source, selfSpiffeid, err := spiffe.Source(ctx, spiffe.EndpointSocket())
        if err != nil </span><span class="cov0" title="0">{
                log.FatalLn(err.Error())
        }</span>
        <span class="cov0" title="0">defer spiffe.CloseSource(source)

        // I should be a SPIKE Keeper.
        if !spiffeid.IsKeeper(env.TrustRoot(), selfSpiffeid) </span><span class="cov0" title="0">{
                log.FatalF("Authenticate: SPIFFE ID %s is not valid.\n", selfSpiffeid)
        }</span>

        <span class="cov0" title="0">log.Log().Info(
                appName, "msg",
                fmt.Sprintf("Started service: %s v%s", appName, config.SpikeKeeperVersion),
        )

        // Serve the app:
        net.Serve(appName, source)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strings"
)

// BannerEnabled returns whether to show initial banner on app start based on
// the SPIKE_BANNER_ENABLED environment variable.
//
// The function reads the SPIKE_BANNER_ENABLED environment variable and returns:
//   - true if the variable is not set (default behavior)
//   - true if the variable is set to "true" (case-insensitive)
//   - false for any other value
//
// The environment variable value is trimmed of whitespace and converted to
// lowercase before comparison.
func BannerEnabled() bool <span class="cov0" title="0">{
        s := os.Getenv("SPIKE_BANNER_ENABLED")
        s = strings.ToLower(strings.TrimSpace(s))
        if s == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return s == "true"</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import "os"

// TrustRoot returns the trust root domain(s) for the application.
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT environment variable.
// If the environment variable is not set, it returns the default value
// "spike.ist". The return value can be a comma-delimited string of multiple
// trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains, comma-delimited if
//     multiple
func TrustRoot() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}

// TrustRootForNexus returns the trust root domain(s) specifically for
// SPIKE Nexus service.
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT_NEXUS environment
// variable. If the environment variable is not set, it returns the default
// value "spike.ist". The return value can be a comma-delimited string of
// multiple trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains for SPIKE Nexus,
//     comma-delimited if multiple
func TrustRootForNexus() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT_NEXUS")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import "os"

// TlsPort returns the TLS port for the Spike Keeper service.
// It first checks for a port specified in the SPIKE_KEEPER_TLS_PORT
// environment variable.
// If no environment variable is set, it defaults to ":8443".
//
// The returned string is in the format ":port" suitable for use with
// net/http Listen functions.
func TlsPort() string <span class="cov10" title="2">{
        p := os.Getenv("SPIKE_KEEPER_TLS_PORT")

        if p != "" </span><span class="cov1" title="1">{
                return p
        }</span>

        <span class="cov1" title="1">return ":8443"</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/net"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/keeper/internal/env"
        http "github.com/spiffe/spike/app/keeper/internal/route/base"
        "github.com/spiffe/spike/internal/log"
        routing "github.com/spiffe/spike/internal/net"
)

// Serve initializes and starts a TLS-secured HTTP server for the given
// application.
//
// Serve uses the provided X509Source for TLS authentication and configures the
// server with the specified HTTP routes. It will listen on the port specified
// by the TLS port environment variable. If the server fails to start, it logs a
// fatal error and terminates the application.
//
// Parameters:
//   - appName: A string identifier for the application, used in error messages
//   - source: An X509Source that provides TLS certificates for the server
//
// The function does not return unless an error occurs, in which case it calls
// log.FatalF and terminates the program.
func Serve(appName string, source *workloadapi.X509Source) <span class="cov0" title="0">{
        if err := net.ServeWithPredicate(
                source,
                func() </span><span class="cov0" title="0">{ routing.HandleRoute(http.Route) }</span>,
                func(peerSpiffeId string) bool <span class="cov0" title="0">{
                        // Only SPIKE Nexus can talk to SPIKE Keeper:
                        return spiffeid.PeerCanTalkToKeeper(env.TrustRootForNexus(), peerSpiffeId)
                }</span>,
                env.TlsPort(),
        ); err != nil <span class="cov0" title="0">{
                log.FatalF("%s: Failed to serve: %s\n", appName, err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package base provides the core routing logic for the SPIKE application's
// HTTP server. It dynamically resolves incoming HTTP requests to the
// appropriate handlers based on their URL paths and methods. This package
// ensures flexibility and extensibility in supporting various API actions and
// paths within SPIKE's ecosystem.
package base

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/url"

        "github.com/spiffe/spike/app/keeper/internal/route/store"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// Route handles all incoming HTTP requests by dynamically selecting and
// executing the appropriate handler based on the request path and HTTP method.
// It uses a factory function to create the specific handler for the given URL
// path and HTTP method combination.
//
// Parameters:
//   - w: The HTTP ResponseWriter to write the response to
//   - r: The HTTP Request containing the client's request details
//   - audit: The AuditEntry containing the client's audit information
func Route(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        return net.RouteFactory[url.ApiAction](
                url.ApiUrl(r.URL.Path),
                url.ApiAction(r.URL.Query().Get(url.KeyApiAction)),
                r.Method,
                func(a url.ApiAction, p url.ApiUrl) net.Handler </span><span class="cov0" title="0">{
                        switch </span>{
                        // Get a contribution from SPIKE Nexus:
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeKeeperUrlContribute:<span class="cov0" title="0">
                                return store.RouteContribute</span>
                        // Provide your shard to SPIKE Nexus:
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeKeeperUrlShard:<span class="cov0" title="0">
                                return store.RouteShard</span>
                        default:<span class="cov0" title="0">
                                return net.Fallback</span>
                        }
                })(w, r, audit)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package store

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/keeper/internal/state"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteContribute handles HTTP requests for shard contributions in the system.
// It processes incoming shard data, decodes it from Base64 encoding, and stores
// it in the system state.
//
// The function expects a Base64-encoded shard and a keeper ID in the request
// body. It performs the following operations:
//   - Reads and validates the request body
//   - Decodes the Base64-encoded shard
//   - Stores the decoded shard in the system state
//   - Logs the operation for auditing purposes
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for tracking the request for auditing purposes
//
// Returns:
//   - error: nil if successful, otherwise one of:
//   - errors.ErrReadFailure if request body cannot be read
//   - errors.ErrParseFailure if request parsing fails or shard decoding fails
//
// Example request body:
//
//        {
//          "shard": "base64EncodedString",
//          "keeperId": "uniqueIdentifier"
//        }
//
// The function returns a 200 OK status with an empty response body on success,
// or a 400 Bad Request status with an error message if the shard content is
// invalid.
func RouteContribute(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeContribute"
        log.AuditRequest(fName, r, audit, log.AuditCreate)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.ShardContributionRequest, reqres.ShardContributionResponse](
                requestBody, w,
                reqres.ShardContributionResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">if request.Shard == nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.ShardContributionResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return errors.ErrInvalidInput
        }</span>

        // Security: Zero out shard before the function exits.
        // [1]
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                mem.ClearRawBytes(request.Shard)
        }</span>()

        // Ensure the client didn't send an array of all zeros, which would
        // indicate invalid input. Since Shard is a fixed-length array in the request,
        // clients must send meaningful non-zero data.
        <span class="cov0" title="0">if mem.Zeroed32(request.Shard) </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.ShardContributionResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return errors.ErrInvalidInput
        }</span>

        // `state.SetShard` copies the shard. We can safely reset this one at [1].
        <span class="cov0" title="0">state.SetShard(request.Shard)

        responseBody := net.MarshalBody(reqres.ShardContributionResponse{}, w)
        net.Respond(http.StatusOK, responseBody, w)

        log.Log().Info(fName, "msg", data.ErrSuccess)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package store

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/keeper/internal/state"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteShard handles HTTP requests to retrieve the stored shard from the
// system. It retrieves the shard from the system state, encodes it in Base64,
// and returns it to the requester.
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for tracking the request for auditing purposes
//
// Returns:
//   - error: nil if successful, otherwise one of:
//   - errors.ErrReadFailure if request body cannot be read
//   - errors.ErrParseFailure if request parsing fails
//   - errors.ErrNotFound if no shard is stored in the system
//
// Response body:
//
//        {
//          "shard": "base64EncodedString"
//        }
//
// The function returns a 200 OK status with the encoded shard on success,
// or a 404 Not Found status if no shard exists in the system.
func RouteShard(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeShard"
        log.AuditRequest(fName, r, audit, log.AuditRead)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.ShardRequest, reqres.ShardResponse](
                requestBody, w,
                reqres.ShardResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">state.RLockShard()
        defer state.RUnlockShard()
        // DO NOT reset `sh` after use, as this function does NOT own it.
        // Treat the value as "read-only".
        sh := state.ShardNoSync()

        if mem.Zeroed32(sh) </span><span class="cov0" title="0">{
                log.Log().Error(fName, "msg", "No shard found")

                responseBody := net.MarshalBody(reqres.ShardResponse{
                        Err: data.ErrNotFound,
                }, w)
                net.Respond(http.StatusNotFound, responseBody, w)

                return errors.ErrNotFound
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.ShardResponse{
                Shard: sh,
        }, w)
        // Security: Reset response body before function exits.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearBytes(responseBody)
        }</span>()

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package state provides thread-safe utilities for securely managing
// and accessing a global shard value. It ensures consistent access
// and updates to the shard using synchronization primitives.
package state

import (
        "sync"
)

var shard [32]byte
var shardMutex sync.RWMutex

// SetShard safely updates the global shard value under a write lock.
// Although the value is a pointer type, it creates a copy. The value `s`
// can be safely erased after calling `SetShard()`.
//
// Parameters:
//   - s *[32]byte: Pointer to the new shard value to store
//
// Thread-safe through shardMutex.
func SetShard(s *[32]byte) <span class="cov0" title="0">{
        shardMutex.Lock()
        defer shardMutex.Unlock()

        zeroed := true
        for i := range s </span><span class="cov0" title="0">{
                if s[i] != 0 </span><span class="cov0" title="0">{
                        zeroed = false
                        break</span>
                }
        }

        // Do not reset the shard if the new value is zero.
        <span class="cov0" title="0">if zeroed </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">copy(shard[:], s[:])</span>
}

// ShardNoSync returns a pointer to the shard without acquiring any locks.
// Callers must ensure proper synchronization by using RLockShard and
// RUnlockShard when accessing the returned pointer.
func ShardNoSync() *[32]byte <span class="cov0" title="0">{
        return &amp;shard
}</span>

// RLockShard acquires a read lock on the shard mutex.
// This should be paired with a corresponding call to RUnlockShard,
// typically using `defer`.
func RLockShard() <span class="cov0" title="0">{
        shardMutex.RLock()
}</span>

// RUnlockShard releases a read lock on the shard mutex.
// This should only be called after a corresponding call to RLockShard.
func RUnlockShard() <span class="cov0" title="0">{
        shardMutex.RUnlock()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package main

import (
        "context"
        "fmt"

        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/initialization"
        "github.com/spiffe/spike/app/nexus/internal/net"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

const appName = "SPIKE Nexus"

func main() <span class="cov0" title="0">{
        if env.BannerEnabled() </span><span class="cov0" title="0">{
                fmt.Printf(`
   \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
 \\\\\ Copyright 2024-present SPIKE contributors.
\\\\\\\ SPDX-License-Identifier: Apache-2.0`+"\n\n"+
                        "%s v%s. | LOG LEVEL: %s\n\n",
                        appName, config.SpikeNexusVersion, log.Level(),
                )
        }</span>

        <span class="cov0" title="0">if mem.Lock() </span><span class="cov0" title="0">{
                log.Log().Info(appName, "msg", "Successfully locked memory.")
        }</span> else<span class="cov0" title="0"> {
                log.Log().Info(appName, "msg", "Memory is not locked. Please disable swap.")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        log.Log().Info(appName, "msg", "SPIFFE Trust Domain: "+env.TrustRoot())

        fmt.Println("before trying to get source...")
        source, selfSpiffeid, err := spiffe.Source(ctx, spiffe.EndpointSocket())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
        <span class="cov0" title="0">defer spiffe.CloseSource(source)

        log.Log().Info(appName, "msg", "self.spiffeid: "+selfSpiffeid)

        // I should be Nexus.
        if !spiffeid.IsNexus(env.TrustRoot(), selfSpiffeid) </span><span class="cov0" title="0">{
                log.FatalF("Authenticate: SPIFFE ID %s is not valid.\n", selfSpiffeid)
        }</span>

        <span class="cov0" title="0">initialization.Initialize(source)

        log.Log().Info(appName, "msg", fmt.Sprintf(
                "Started service: %s v%s",
                appName, config.SpikeNexusVersion),
        )

        // Start the server:
        net.Serve(appName, source)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strings"
)

// StoreType represents the type of backend storage to use.
type StoreType string

const (
        // S3 indicates an Amazon S3 (or compatible) storage backend
        S3 StoreType = "s3"

        // Sqlite indicates a SQLite database storage backend
        // This is the default backing store. SPIKE_NEXUS_BACKEND_STORE environment
        // variable can override it.
        Sqlite StoreType = "sqlite"

        // Memory indicates an in-memory storage backend
        Memory StoreType = "memory"
)

// BackendStoreType determines which storage backend type to use based on the
// SPIKE_NEXUS_BACKEND_STORE environment variable. The value is
// case-insensitive.
//
// Valid values are:
//   - "s3": Uses an AWS S3-compatible medium as a backing store.
//   - "sqlite": Uses SQLite database storage
//   - "memory": Uses in-memory storage
//
// If the environment variable is not set or contains an invalid value,
// it defaults to Memory.
func BackendStoreType() StoreType <span class="cov0" title="0">{
        st := os.Getenv("SPIKE_NEXUS_BACKEND_STORE")

        switch strings.ToLower(st) </span>{
        case string(S3):<span class="cov0" title="0">
                panic("SPIKE_NEXUS_BACKEND_STORE=s3 is not implemented yet")</span>
        case string(Sqlite):<span class="cov0" title="0">
                return Sqlite</span>
        case string(Memory):<span class="cov0" title="0">
                return Memory</span>
        default:<span class="cov0" title="0">
                return Sqlite</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strconv"
        "time"
)

// DatabaseJournalMode returns the SQLite journal mode to use.
// It can be configured using the SPIKE_NEXUS_DB_JOURNAL_MODE environment
// variable.
//
// If the environment variable is not set, it defaults to "WAL"
// (Write-Ahead Logging).
func DatabaseJournalMode() string <span class="cov0" title="0">{
        s := os.Getenv("SPIKE_NEXUS_DB_JOURNAL_MODE")
        if s != "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return "WAL"</span>
}

// DatabaseBusyTimeoutMs returns the SQLite busy timeout in milliseconds.
// It can be configured using the SPIKE_NEXUS_DB_BUSY_TIMEOUT_MS environment
// variable. The value must be a positive integer.
//
// If the environment variable is not set or contains an invalid value,
// it defaults to 5000 milliseconds (5 seconds).
func DatabaseBusyTimeoutMs() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_BUSY_TIMEOUT_MS")
        if p != "" </span><span class="cov0" title="0">{
                bt, err := strconv.Atoi(p)
                if err == nil &amp;&amp; bt &gt; 0 </span><span class="cov0" title="0">{
                        return bt
                }</span>
        }

        <span class="cov0" title="0">return 5000</span>
}

// DatabaseMaxOpenConns returns the maximum number of open database connections.
// It can be configured using the SPIKE_NEXUS_DB_MAX_OPEN_CONNS environment
// variable. The value must be a positive integer.
//
// If the environment variable is not set or contains an invalid value,
// it defaults to 10 connections.
func DatabaseMaxOpenConns() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_MAX_OPEN_CONNS")
        if p != "" </span><span class="cov0" title="0">{
                moc, err := strconv.Atoi(p)
                if err == nil &amp;&amp; moc &gt; 0 </span><span class="cov0" title="0">{
                        return moc
                }</span>
        }

        <span class="cov0" title="0">return 10</span>
}

// DatabaseMaxIdleConns returns the maximum number of idle database connections.
// It can be configured using the SPIKE_NEXUS_DB_MAX_IDLE_CONNS environment
// variable. The value must be a positive integer.
//
// If the environment variable is not set or contains an invalid value,
// it defaults to 5 connections.
func DatabaseMaxIdleConns() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_MAX_IDLE_CONNS")
        if p != "" </span><span class="cov0" title="0">{
                mic, err := strconv.Atoi(p)
                if err == nil &amp;&amp; mic &gt; 0 </span><span class="cov0" title="0">{
                        return mic
                }</span>
        }

        <span class="cov0" title="0">return 5</span>
}

// DatabaseConnMaxLifetimeSec returns the maximum lifetime duration for a
// database connection. It can be configured using the
// SPIKE_NEXUS_DB_CONN_MAX_LIFETIME environment variable.
// The value should be a valid Go duration string (e.g., "1h", "30m").
//
// If the environment variable is not set or contains an invalid duration,
// it defaults to 1 hour.
func DatabaseConnMaxLifetimeSec() time.Duration <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_CONN_MAX_LIFETIME")
        if p != "" </span><span class="cov0" title="0">{
                d, err := time.ParseDuration(p)
                if err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }

        <span class="cov0" title="0">return time.Hour</span>
}

// DatabaseOperationTimeout returns the duration to use for database operations.
// It can be configured using the SPIKE_NEXUS_DB_OPERATION_TIMEOUT environment
// variable. The value should be a valid Go duration string (e.g., "10s", "1m").
//
// If the environment variable is not set or contains an invalid duration,
// it defaults to 15 seconds.
func DatabaseOperationTimeout() time.Duration <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_OPERATION_TIMEOUT")
        if p != "" </span><span class="cov0" title="0">{
                d, err := time.ParseDuration(p)
                if err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }

        <span class="cov0" title="0">return 15 * time.Second</span>
}

// DatabaseInitializationTimeout returns the duration to wait for database
// initialization.
//
// The timeout is read from the environment variable
// `SPIKE_NEXUS_DB_INITIALIZATION_TIMEOUT`. If this variable is set and its
// value can be parsed as a duration (e.g., "1m30s"), it is used.
// Otherwise, the function defaults to a timeout of 30 seconds.
func DatabaseInitializationTimeout() time.Duration <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_INITIALIZATION_TIMEOUT")
        if p != "" </span><span class="cov0" title="0">{
                d, err := time.ParseDuration(p)
                if err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov0" title="0">return 30 * time.Second</span>
}

// DatabaseSkipSchemaCreation determines if schema creation should be skipped.
// It checks the "SPIKE_NEXUS_DB_SKIP_SCHEMA_CREATION" env variable to decide.
// If the env variable is set and its value is "true", it returns true.
// Otherwise, it returns false.
func DatabaseSkipSchemaCreation() bool <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_DB_SKIP_SCHEMA_CREATION")
        if p != "" </span><span class="cov0" title="0">{
                s, err := strconv.ParseBool(p)
                if err == nil </span><span class="cov0" title="0">{
                        return s
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "fmt"
        "net/url"
        "os"
        "strconv"
        "strings"
)

// validUrl validates that a URL is properly formatted and uses HTTPS
func validUrl(urlStr string) bool <span class="cov0" title="0">{
        parsedUrl, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return parsedUrl.Scheme == "https" &amp;&amp; parsedUrl.Host != ""</span>
}

// Keepers retrieves and parses the keeper peer configurations from the
// environment. It reads SPIKE_NEXUS_KEEPER_PEERS environment variable which
// should contain a comma-separated list of keeper URLs.
//
// The environment variable should be formatted as:
// 'https://localhost:8443,https://localhost:8543,https://localhost:8643'
//
// The SPIKE Keeper address mappings will be automatically assigned starting
// with the key "1" and incrementing by 1 for each subsequent SPIKE Keeper.
//
// Returns:
//   - map[string]string: Mapping of keeper IDs to their URLs
//
// Panics if:
//   - SPIKE_NEXUS_KEEPER_PEERS is not set
func Keepers() map[string]string <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_KEEPER_PEERS")

        if p == "" </span><span class="cov0" title="0">{
                panic("SPIKE_NEXUS_KEEPER_PEERS has to be configured in the environment")</span>
        }

        <span class="cov0" title="0">urls := strings.Split(p, ",")

        // Check for duplicate and empty URLs
        urlMap := make(map[string]bool)
        for i, u := range urls </span><span class="cov0" title="0">{
                trimmedURL := strings.TrimSpace(u)
                if trimmedURL == "" </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Keepers: Empty URL found at position %d", i+1))</span>
                }

                // Validate URL format and security
                <span class="cov0" title="0">if !validUrl(trimmedURL) </span><span class="cov0" title="0">{
                        panic(
                                fmt.Sprintf(
                                        "Invalid or insecure URL at position %d: %s", i+1,
                                        trimmedURL),
                        )</span>
                }

                <span class="cov0" title="0">if urlMap[trimmedURL] </span><span class="cov0" title="0">{
                        panic("Duplicate keeper URL detected: " + trimmedURL)</span>
                }

                <span class="cov0" title="0">urlMap[trimmedURL] = true</span>
        }

        // The key of the map is the Shamir Shard index (starting from 1), and
        // the value is the Keeper URL that corresponds to that shard index.
        <span class="cov0" title="0">peers := make(map[string]string)
        for i, u := range urls </span><span class="cov0" title="0">{
                peers[strconv.Itoa(i+1)] = strings.TrimSpace(u)
        }</span>

        <span class="cov0" title="0">return peers</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import "os"

// TlsPort returns the TLS port for the Spike Nexus service.
// It reads from the SPIKE_NEXUS_TLS_PORT environment variable.
// If the environment variable is not set, it returns the default port ":8553".
func TlsPort() string <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_TLS_PORT")
        if p != "" </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov0" title="0">return ":8553"</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strings"
)

// BannerEnabled returns whether to show initial banner on app start based on
// the SPIKE_BANNER_ENABLED environment variable.
//
// The function reads the SPIKE_BANNER_ENABLED environment variable and returns:
//   - true if the variable is not set (default behavior)
//   - true if the variable is set to "true" (case-insensitive)
//   - false for any other value
//
// The environment variable value is trimmed of whitespace and converted to
// lowercase before comparison.
func BannerEnabled() bool <span class="cov0" title="0">{
        s := os.Getenv("SPIKE_BANNER_ENABLED")
        s = strings.ToLower(strings.TrimSpace(s))
        if s == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return s == "true"</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "time"
)

// RecoveryOperationTimeout returns the recovery timeout duration.
// It reads from the SPIKE_NEXUS_RECOVERY_TIMEOUT environment variable
//
// If the environment variable is not set or is not a valid duration string,
// then it defaults to `0` (no timeout limit).
func RecoveryOperationTimeout() time.Duration <span class="cov0" title="0">{
        e := os.Getenv("SPIKE_NEXUS_RECOVERY_TIMEOUT")
        if e != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(e); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// RecoveryOperationMaxInterval returns the maximum interval duration for
// recovery backoff retry algorithm. The interval is determined by the
// environment variable `SPIKE_NEXUS_RECOVERY_MAX_INTERVAL`.
//
// If the environment variable is not set or is not a valid duration
// string, then it defaults to 60 seconds.
func RecoveryOperationMaxInterval() time.Duration <span class="cov0" title="0">{
        e := os.Getenv("SPIKE_NEXUS_RECOVERY_MAX_INTERVAL")
        if e != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(e); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov0" title="0">return 60 * time.Second</span>
}

// RecoveryOperationPollInterval returns the duration to wait between attempts
// to poll the list of SPIKE Keepers during initialization. It first checks the
// "SPIKE_NEXUS_RECOVERY_POLL_INTERVAL" environment variable, parsing it as a
// duration if set. If the environment variable is not set or cannot be parsed
// as a valid duration, it defaults to 5 seconds.
//
// The function is used to configure the polling interval when waiting for
// keepers to initialize in the bootstrap process.
func RecoveryOperationPollInterval() time.Duration <span class="cov0" title="0">{
        e := os.Getenv("SPIKE_NEXUS_RECOVERY_POLL_INTERVAL")
        if e != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(e); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }

        <span class="cov0" title="0">return 5 * time.Second</span>
}

// RecoveryKeeperUpdateInterval returns the duration between keeper updates for
// SPIKE Nexus. It first attempts to read the duration from the
// SPIKE_NEXUS_KEEPER_UPDATE_INTERVAL environment variable. If the environment
// variable is set and contains a valid duration string (as parsed by
// time.ParseDuration), that duration is returned. Otherwise, it returns a
// default value of 5 minutes.
func RecoveryKeeperUpdateInterval() time.Duration <span class="cov0" title="0">{
        e := os.Getenv("SPIKE_NEXUS_KEEPER_UPDATE_INTERVAL")
        if e != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(e); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }

        <span class="cov0" title="0">return 5 * time.Minute</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strconv"
)

// MaxSecretVersions returns the maximum number of versions to retain for each
// secret. It reads from the SPIKE_NEXUS_MAX_SECRET_VERSIONS environment
// variable which should contain a positive integer value.
// If the environment variable is not set, contains an invalid integer, or
// specifies a non-positive value, it returns the default of 10 versions.
func MaxSecretVersions() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_MAX_SECRET_VERSIONS")
        if p != "" </span><span class="cov0" title="0">{
                mv, err := strconv.Atoi(p)
                if err == nil &amp;&amp; mv &gt; 0 </span><span class="cov0" title="0">{
                        return mv
                }</span>
        }

        <span class="cov0" title="0">return 10</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strconv"
)

// ShamirShares returns the total number of shares to be used in Shamir's
// Secret Sharing. It reads the value from the SPIKE_NEXUS_SHAMIR_SHARES
// environment variable.
//
// Returns:
//   - The number of shares specified in the environment variable if it's a
//     valid positive integer
//   - The default value of 3 if the environment variable is unset, empty,
//     or invalid
//
// This determines the total number of shares that will be created when
//
//        splitting a secret.
func ShamirShares() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_SHAMIR_SHARES")
        if p != "" </span><span class="cov0" title="0">{
                mv, err := strconv.Atoi(p)
                if err == nil &amp;&amp; mv &gt; 0 </span><span class="cov0" title="0">{
                        return mv
                }</span>
        }

        <span class="cov0" title="0">return 3</span>
}

// ShamirThreshold returns the minimum number of shares required to reconstruct
// the secret in Shamir's Secret Sharing scheme.
// It reads the value from the SPIKE_NEXUS_SHAMIR_THRESHOLD environment
// variable.
//
// Returns:
//   - The threshold specified in the environment variable if it's a valid
//     positive integer
//   - The default value of 2 if the environment variable is unset, empty,
//     or invalid
//
// This threshold value determines how many shares are needed to recover the
// original secret. It should be less than or equal to the total number of
// shares (ShamirShares()).
func ShamirThreshold() int <span class="cov0" title="0">{
        p := os.Getenv("SPIKE_NEXUS_SHAMIR_THRESHOLD")
        if p != "" </span><span class="cov0" title="0">{
                mv, err := strconv.Atoi(p)
                if err == nil &amp;&amp; mv &gt; 0 </span><span class="cov0" title="0">{
                        return mv
                }</span>
        }

        <span class="cov0" title="0">return 2</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import "os"

// TrustRoot returns the trust root domain(s) for the application.
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT environment variable.
// If the environment variable is not set, it returns the default value
// "spike.ist". The return value can be a comma-delimited string of multiple
// trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains, comma-delimited if
//     multiple
func TrustRoot() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}

// TrustRootForKeeper returns the trust root domain(s) specifically for
// SPIKE Keeper service.
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT_KEEPER environment
// variable. If the environment variable is not set, it returns the default
// value "spike.ist". The return value can be a comma-delimited string of
// multiple trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains for SPIKE Keeper,
//     comma-delimited if multiple
func TrustRootForKeeper() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT_KEEPER")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}

// TrustRootForPilot returns the trust root domain(s) specifically for
// SPIKE Pilot (i.e., the `spike` binary).
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT_PILOT environment
// variable. If the environment variable is not set, it returns the default
// value "spike.ist". The return value can be a comma-delimited string of
// multiple trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains for Pilot,
//     comma-delimited if multiple
func TrustRootForPilot() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT_PILOT")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package initialization

import (
        "os"

        "github.com/spiffe/go-spiffe/v2/workloadapi"

        "github.com/spiffe/spike/app/nexus/internal/initialization/recovery"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

// bootstrap initializes the SPIKE Nexus by either recovering from the existing
// state or creating a new root key. The function determines the appropriate
// initialization // strategy based on system state indicators.
//
// Parameters:
//   - source *workloadapi.X509Source: Authentication source for SPIFFE workload
//     API
//
// The function follows this decision flow:
//  1. Check for a tombstone file as an indicator of previous bootstrapping
//  2. If tombstone exists, perform recovery using keeper shards
//  3. If the tombstone check fails for reasons other than non-existence, attempt
//     recovery
//  4. If no tombstone exists, assume first-time initialization and create a
//     new root key
//
// The function will:
//   - Log and terminate if a nil source is provided
//   - Recover existing state if SPIKE Nexus was previously bootstrapped
//   - Create a new root key if no previous state is detected
//   - Hydrate in-memory data stores after recovery or initialization
//
// Errors:
//   - Fatal error if the source parameter is nil
//   - Warning on tombstone file check errors, with fallback to recovery
func bootstrap(source *workloadapi.X509Source) <span class="cov0" title="0">{
        const fName = "bootstrap"

        if source == nil </span><span class="cov0" title="0">{
                // If `source` is nil, nobody is going to recreate the source,
                // it's better to log and crash.
                log.FatalLn(fName + ": source is nil. this should not happen.")
        }</span>

        // The tombstone file is a fast heuristic to validate SPIKE Nexus bootstrap
        // completion. However, it's not the ultimate criterion. If we cannot
        // find a tombstone file, then we'll query existing SPIKE Keeper instances
        // for shard information until we get enough shards to reconstruct
        // the root key. If that, too, fails, then a human operator will need to
        // manually re-key SPIKE Nexus.
        <span class="cov0" title="0">tombstone := config.SpikeNexusTombstonePath()

        _, err := os.Stat(tombstone)

        nexusAlreadyBootstrapped := err == nil
        if nexusAlreadyBootstrapped </span><span class="cov0" title="0">{
                log.Log().Info(fName,
                        "msg", "Tombstone file exists, "+
                                "SPIKE Nexus is bootstrapped. Will try keeper recovery",
                )

                recovery.RecoverBackingStoreUsingKeeperShards(source)
                recovery.HydrateMemoryFromBackingStore()
                return
        }</span>

        <span class="cov0" title="0">bootstrapStatusCheckFailed := !os.IsNotExist(err)
        if bootstrapStatusCheckFailed </span><span class="cov0" title="0">{
                // This should not typically happen.

                log.Log().Warn(fName,
                        "msg", "Failed to check tombstone file. Will try keeper recovery",
                        "err", err,
                )

                recovery.RecoverBackingStoreUsingKeeperShards(source)
                recovery.HydrateMemoryFromBackingStore()
                return
        }</span>

        // If the flow reaches here, we assume SPIKE Nexus has not bootstrapped
        // and it's day zero. Let's bootstrap SPIKE Nexus with a fresh root key:
        <span class="cov0" title="0">recovery.BootstrapBackingStoreWithNewRootKey(source)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package initialization

import (
        "crypto/rand"

        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/initialization/recovery"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
)

// Initialize sets up the system state based on the backend store type.
// For SQLite backends, it performs bootstrapping and starts periodic shard
// synchronization.  For in-memory stores, it initializes with a random seed.
//
// Parameters:
//   - source: *workloadapi.X509Source for SPIFFE workload API authentication
//
// The function will:
//   - Bootstrap from SQLite if using SQLite backend
//   - Start periodic shard syncing for SQLite backend
//   - Initialize with random seed for in-memory backend
//
// Panics if random seed generation fails for in-memory stores.
func Initialize(source *workloadapi.X509Source) <span class="cov0" title="0">{
        const fName = "Initialize"
        requireBootstrapping := env.BackendStoreType() == env.Sqlite
        if requireBootstrapping </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Backend store requires bootstrapping")

                // Try bootstrapping in a loop.
                go bootstrap(source)

                // Lazy evaluation in a loop:
                // If bootstrapping is successful, start a background process to
                // periodically sync shards.
                go recovery.SendShardsPeriodically(source)

                return
        }</span>

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Backend store does not require bootstrapping")

        // Security: Use a static byte array and pass it as a pointer to avoid
        // inadvertent pass-by-value copying / memory allocation.
        var seed [32]byte

        // Security: Zero-out seed after use.
        defer func() </span><span class="cov0" title="0">{
                // Note: Each function must zero-out ONLY the items it has created.
                // If it is borrowing an item by reference, it must not zero-out the item
                // and let the owner zero-out the item.
                //
                // For example, `seed` should be reset here,
                // but not in `state.Initialize()`.
                mem.ClearRawBytes(&amp;seed)
        }</span>()

        <span class="cov0" title="0">if _, err := rand.Read(seed[:]); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>

        <span class="cov0" title="0">state.Initialize(&amp;seed)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "encoding/json"
        "net/url"
        "os"
        "strconv"

        "github.com/cloudflare/circl/group"
        "github.com/cloudflare/circl/secretsharing"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiUrl "github.com/spiffe/spike-sdk-go/api/url"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/nexus/internal/env"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

func iterateKeepersToBootstrap(
        keepers map[string]string, rootShares []secretsharing.Share,
        successfulKeepers map[string]bool, source *workloadapi.X509Source,
) bool <span class="cov0" title="0">{
        const fName = "iterateKeepersToBootstrap"

        for keeperId, keeperApiRoot := range keepers </span><span class="cov0" title="0">{
                u, err := url.JoinPath(
                        keeperApiRoot, string(apiUrl.SpikeKeeperUrlContribute),
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(
                                fName, "msg", "Failed to join path", "url", keeperApiRoot,
                        )
                        continue</span>
                }

                <span class="cov0" title="0">var share secretsharing.Share

                for _, sr := range rootShares </span><span class="cov0" title="0">{
                        kid, err := strconv.Atoi(keeperId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Log().Warn(
                                        fName, "msg", "Failed to convert keeper id to int", "err", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if sr.ID.IsEqual(group.P256.NewScalar().SetUint64(uint64(kid))) </span><span class="cov0" title="0">{
                                share = sr
                                break</span>
                        }
                }

                // If initialized, IDs start from 1. Zero means there is no match.
                <span class="cov0" title="0">if share.ID.IsZero() </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg",
                                "Failed to find share for keeper", "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">contribution, err := share.Value.MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg",
                                "Failed to marshal share", "err", err, "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">data := shardContributionResponse(u, &amp;contribution, source)
                if len(data) == 0 </span><span class="cov0" title="0">{
                        // Security: Ensure that the share is zeroed out
                        // before the function returns.
                        mem.ClearBytes(contribution)

                        log.Log().Info(fName, "msg", "No data; moving on...")
                        continue</span>
                }

                // Security: Ensure that the share is zeroed out
                // before the function returns.
                <span class="cov0" title="0">mem.ClearBytes(contribution)

                var res reqres.ShardContributionResponse
                err = json.Unmarshal(data, &amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg", "Failed to unmarshal response", "err", err)
                        continue</span>
                }

                <span class="cov0" title="0">successfulKeepers[keeperId] = true
                log.Log().Info(fName, "msg", "Success", "keeper_id", keeperId)

                if len(successfulKeepers) == env.ShamirShares() </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg", "All keepers initialized")

                        tombstone := config.SpikeNexusTombstonePath()

                        // Create the tombstone file to mark SPIKE Nexus as bootstrapped.
                        // 0600 to align with the principle of least privilege. We can change the
                        // permission if it doesn't work out.
                        err = os.WriteFile(
                                tombstone,
                                []byte("spike.nexus.bootstrapped=true"), 0600,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                // Although the tombstone file is just a marker, it's still important.
                                // If SPIKE Nexus cannot create the tombstone file, or if someone
                                // deletes it, this can slightly change system operations.
                                // To be on the safe side, we let SPIKE Nexus crash. If we don't let
                                // it crash, not being able to write to the data volume (where the
                                // tombstone file would be) can be a precursor of other problems that
                                // can affect the reliability of the backing store.
                                log.FatalLn(fName + ": failed to create tombstone file: " + err.Error())
                        }</span>

                        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Tombstone file created successfully")
                        return true</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func iterateKeepersAndTryRecovery(
        source *workloadapi.X509Source,
        successfulKeeperShards map[string]*[32]byte,
) bool <span class="cov0" title="0">{
        const fName = "iterateKeepersAndTryRecovery"

        for keeperId, keeperApiRoot := range env.Keepers() </span><span class="cov0" title="0">{
                log.Log().Info(fName, "id", keeperId, "url", keeperApiRoot)

                u := shardUrl(keeperApiRoot)
                if u == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">data := shardResponse(source, u)
                if len(data) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">res := unmarshalShardResponse(data)
                // Security: Reset data before the function exits.
                mem.ClearBytes(data)

                if res == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if mem.Zeroed32(res.Shard) </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg", "Shard is zeroed")
                        continue</span>
                }

                <span class="cov0" title="0">successfulKeeperShards[keeperId] = res.Shard
                if len(successfulKeeperShards) != env.ShamirThreshold() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // No need to erase `ss` because upon successful recovery,
                // `RecoverBackingStoreUsingKeeperShards()` resets `successfulKeeperShards`
                // which points to the same shards here. And until recovery, we will keep
                // a threshold number of shards in memory.
                <span class="cov0" title="0">ss := make([]ShamirShard, 0)
                for ix, shard := range successfulKeeperShards </span><span class="cov0" title="0">{
                        id, err := strconv.Atoi(ix)
                        if err != nil </span><span class="cov0" title="0">{
                                // This is a configuration error; we cannot recover from it,
                                // and it may cause further security issues. Crash immediately.
                                log.FatalLn(
                                        fName, "msg", "Failed to convert keeper Id to int", "err", err,
                                )
                                continue</span>
                        }

                        <span class="cov0" title="0">ss = append(ss, ShamirShard{
                                Id:    uint64(id),
                                Value: shard,
                        })</span>
                }

                <span class="cov0" title="0">binaryRec := RecoverRootKey(ss)

                // Both of these methods directly or indirectly make a copy of `binaryRec`
                // It is okay to zero out `binaryRec` after calling these two functions.
                state.Initialize(binaryRec)
                state.SetRootKey(binaryRec)

                // Security: Zero out temporary variables before the function exits.
                mem.ClearRawBytes(binaryRec)
                // Security: Zero out temporary variables before the function exits.
                // Note that `successfulKeeperShards` will be reset elsewhere.
                mem.ClearRawBytes(res.Shard)

                // System initialized: Exit infinite loop.
                return true</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
        "time"

        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/retry"
        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "math/big"

        "github.com/spiffe/spike/app/nexus/internal/env"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/app/nexus/internal/state/persist"
        "github.com/spiffe/spike/internal/log"
)

var (
        ErrRecoveryRetry = errors.New("recovery failed; retrying")
)

// RecoverBackingStoreUsingKeeperShards iterates through keepers until
// you get two shards.
//
// Any 400 and 5xx response that a SPIKE Keeper gives is likely temporary.
// We should keep trying until we get a 200 or 404 response.
//
// This function attempts to recover the backing store by collecting shards
// from keeper nodes. It continuously polls the keepers until enough valid
// shards are collected to reconstruct the backing store. The function blocks
// until recovery is successful.
//
// The function maintains a map of successfully recovered shards from each
// keeper to avoid duplicate processing. On failure, it retries with an
// exponential backoff with a max retry delay of 5 seconds.
// The retry timeout is loaded from `env.RecoveryOperationTimeout` and
// defaults to 0 (unlimited; no timeout).
//
// Parameters:
//   - source *workloadapi.X509Source: An X509Source used for authenticating
//     with SPIKE Keeper nodes
func RecoverBackingStoreUsingKeeperShards(source *workloadapi.X509Source) <span class="cov0" title="0">{
        const fName = "RecoverBackingStoreUsingKeeperShards"

        log.Log().Info(fName, "msg", "Recovering backing store using keeper shards")

        successfulKeeperShards := make(map[string]*[32]byte)
        // Security: Ensure the shards are zeroed out after use.
        defer func() </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Resetting successfulKeeperShards")
                for id := range successfulKeeperShards </span><span class="cov0" title="0">{
                        // Note: you cannot simply use `mem.ClearRawBytes(successfulKeeperShards)`
                        // because it will reset the pointer but not the data it points to.
                        mem.ClearRawBytes(successfulKeeperShards[id])
                }</span>
        }()

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(
                context.Background(),
        )
        defer cancel()

        _, err := retry.Do(ctx, func() (bool, error) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "retry:"+time.Now().String())

                recoverySuccessful := iterateKeepersAndTryRecovery(
                        source, successfulKeeperShards,
                )
                if recoverySuccessful </span><span class="cov0" title="0">{
                        log.Log().Info(fName, "msg", "Recovery successful")
                        return true, nil
                }</span>

                <span class="cov0" title="0">log.Log().Warn(fName, "msg", "Recovery unsuccessful. Will retry.")
                log.Log().Warn(fName, "msg",
                        fmt.Sprintf(
                                "Successful keepers: %d", len(successfulKeeperShards),
                        ),
                )
                log.Log().Warn(fName, "msg", "!!! YOU MAY NEED TO MANUALLY BOOSTRAP !!!")
                log.Log().Info(fName, "msg", "Waiting for keepers to respond")
                return false, ErrRecoveryRetry</span>
        },
                retry.WithBackOffOptions(
                        retry.WithMaxInterval(env.RecoveryOperationMaxInterval()),
                        retry.WithMaxElapsedTime(env.RecoveryOperationTimeout()),
                ),
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn("Recovery failed; timed out")
                log.Log().Warn("You need to manually bootstrap SPIKE Nexus")
        }</span>
}

// HydrateMemoryFromBackingStore loads all secrets from the persistent storage
// into the application's memory state. This function is typically called during
// application startup to restore the secret state from the previous session.
//
// The function reads all secrets from the backing store using
// persist.ReadAllSecrets() and imports them into the application state using
// state.ImportSecrets(). If no secrets are found in the backing store, the
// function returns without making any changes to the application state.
//
// Example usage:
//
//        func initializeApp() {
//                // Other initialization code...
//                memory.HydrateMemoryFromBackingStore()
//                // Continue with application startup
//        }
func HydrateMemoryFromBackingStore() <span class="cov0" title="0">{
        const fName = "HydrateMemoryFromBackingStore"

        log.Log().Info(fName, "msg", "HydrateMemoryFromBackingStore")

        secrets := persist.ReadAllSecrets()
        if len(secrets) &gt; 0 </span><span class="cov0" title="0">{
                state.ImportSecrets(secrets)
        }</span>
        <span class="cov0" title="0">log.Log().Info(fName, "msg", "HydrateMemoryFromBackingStore: secrets loaded")

        policies := persist.ReadAllPolicies()
        if len(policies) &gt; 0 </span><span class="cov0" title="0">{
                state.ImportPolicies(policies)
        }</span>

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "HydrateMemoryFromBackingStore: policies loaded")</span>
}

// RestoreBackingStoreUsingPilotShards restores the backing store using the
// provided Shamir secret sharing shards. It requires at least the threshold
// number of shards (as configured in the environment) to successfully
// recover the root key. Once the root key is recovered, it initializes the
// state and sends the shards to the keepers.
//
// Parameters:
//   - shards []*[32]byte: A slice of byte array pointers representing the shards
//
// The function will:
//   - Validate that enough shards are provided (at least the threshold amount)
//   - Recover the root key using the Shamir secret sharing algorithm
//   - Initialize the state with the recovered key
//   - Send the shards to the configured keepers
//
// It will return early with an error log if:
//   - There are insufficient shards to meet the threshold
//   - The SPIFFE source cannot be created
func RestoreBackingStoreUsingPilotShards(shards []ShamirShard) <span class="cov0" title="0">{
        const fName = "RestoreBackingStoreUsingPilotShards"

        log.Log().Info(fName, "msg", "Restoring backing store using pilot shards")

        // Sanity check:
        for shard := range shards </span><span class="cov0" title="0">{
                value := shards[shard].Value
                id := shards[shard].Id

                if mem.Zeroed32(value) || id == 0 </span><span class="cov0" title="0">{
                        log.Log().Error(
                                fName,
                                "msg", "Bad input: ID or Value of a shard is zero. Exiting recovery",
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Log().Info(fName,
                "msg", "Recovering backing store using pilot shards",
                "threshold", env.ShamirThreshold(),
                "len", len(shards),
        )

        // Ensure we have at least the threshold number of shards
        if len(shards) &lt; env.ShamirThreshold() </span><span class="cov0" title="0">{
                log.Log().Error(fName, "msg", "Insufficient shards for recovery",
                        "provided", len(shards), "required", env.ShamirThreshold())
                return
        }</span>

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Recovering backing store using pilot shards")

        // Recover the root key using the threshold number of shards
        binaryRec := RecoverRootKey(shards)
        // Security: Ensure the root key is zeroed out after use.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearRawBytes(binaryRec)
        }</span>()

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Initializing state and root key")
        state.Initialize(binaryRec)
        state.SetRootKey(binaryRec)

        source, _, err := spiffe.Source(
                context.Background(), spiffe.EndpointSocket(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Failed to create source", "err", err)
                return
        }</span>
        <span class="cov0" title="0">defer spiffe.CloseSource(source)

        // Don't wait for the next cycle. Send the shards asap.
        sendShardsToKeepers(source, env.Keepers())</span>
}

// SendShardsPeriodically distributes key shards to configured keeper nodes at
// regular intervals. It creates new shards from the current root key and sends
// them to each keeper using mTLS authentication. The function runs indefinitely
// until stopped.
//
// The function sends shards every 5 minutes. It requires a minimum number of keepers
// equal to the configured Shamir shares. If any operation fails for a keeper
// (URL creation, mTLS setup, marshaling, or network request), it logs a warning
// and continues with the next keeper.
//
// Parameters:
//   - source *workloadapi.X509Source: An X509Source used for creating mTLS
//     connections to keepers
func SendShardsPeriodically(source *workloadapi.X509Source) <span class="cov0" title="0">{
        const fName = "SendShardsPeriodically"

        log.Log().Info(fName, "msg", "Will send shards to keepers")

        ticker := time.NewTicker(env.RecoveryKeeperUpdateInterval())
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Sending shards to keepers")

                // if no root key, then skip.
                if state.RootKeyZero() </span><span class="cov0" title="0">{
                        log.Log().Warn(fName, "msg", "No root key; skipping")
                        continue</span>
                }

                <span class="cov0" title="0">keepers := env.Keepers()
                if len(keepers) &lt; env.ShamirShares() </span><span class="cov0" title="0">{
                        log.FatalLn(fName + ": not enough keepers")
                }</span>

                <span class="cov0" title="0">sendShardsToKeepers(source, keepers)</span>
        }
}

// NewPilotRecoveryShards generates a set of recovery shards from the root key
// using Shamir's Secret Sharing scheme. These shards can be used to reconstruct
// the root key in a recovery scenario.
//
// The function first retrieves the root key from the system state. If no root
// key exists, it returns an empty slice. Otherwise, it splits the root key into
// shares using a secret sharing scheme, performs validation checks, and
// converts the shares into byte arrays.
//
// Each shard in the returned slice represents a portion of the secret needed to
// reconstruct the root key. The shares are generated in a way that requires a
// specific threshold of shards to be combined to recover the original secret.
//
// Returns:
//   - []*[32]byte: A slice of byte array pointers representing the recovery
//     shards. Returns an empty slice if the root key is not available or if
//     share generation fails.
//
// Example:
//
//        shards := NewPilotRecoveryShards()
//        for _, shard := range shards {
//            // Store each shard securely
//            storeShard(shard)
//        }
func NewPilotRecoveryShards() map[int]*[32]byte <span class="cov0" title="0">{
        const fName = "NewPilotRecoveryShards"
        log.Log().Info(fName, "msg", "Generating pilot recovery shards")

        if state.RootKeyZero() </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg", "No root key; skipping")
                return nil
        }</span>

        <span class="cov0" title="0">rootSecret, rootShares := computeShares()
        // Security: Ensure the root key and shares are zeroed out after use.
        sanityCheck(rootSecret, rootShares)
        defer func() </span><span class="cov0" title="0">{
                rootSecret.SetUint64(0)
                for i := range rootShares </span><span class="cov0" title="0">{
                        rootShares[i].Value.SetUint64(0)
                }</span>
        }()

        <span class="cov0" title="0">var result = make(map[int]*[32]byte)

        for _, share := range rootShares </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Generating share", "share.id", share.ID)

                contribution, err := share.Value.MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "Failed to marshal share")
                        return nil
                }</span>

                <span class="cov0" title="0">if len(contribution) != 32 </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "Length of share is unexpected")
                        return nil
                }</span>

                <span class="cov0" title="0">bb, err := share.ID.MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "Failed to unmarshal share Id")
                        return nil
                }</span>

                <span class="cov0" title="0">bigInt := new(big.Int).SetBytes(bb)
                ii := bigInt.Uint64()

                if len(contribution) != 32 </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "Length of share is unexpected")
                        return nil
                }</span>

                <span class="cov0" title="0">var rs [32]byte
                copy(rs[:], contribution)

                log.Log().Info(fName, "msg", "Generated shares", "len", len(rs))

                result[int(ii)] = &amp;rs</span>
        }

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Successfully generated pilot recovery shards.")
        return result</span>
}

// BootstrapBackingStoreWithNewRootKey initializes the backing store with a new
// root key if it hasn't been bootstrapped already. It generates a new AES-256
// root key, initializes the state with this key, and distributes key shards
// to all configured keepers.
//
// The function requires the number of keepers to match the configured Shamir
// shares. It continuously attempts to distribute shards to all keepers until
// successful, waiting 5 seconds between retry attempts. The backing store is
// initialized before keeper distribution to allow immediate operation.
//
// Parameters:
//   - source *workloadapi.X509Source: An X509Source used for authenticating
//     with keeper nodes
//
// The function will crash fatally if:
//   - Root key creation fails
//   - The number of keepers doesn't match the configured Shamir shares
func BootstrapBackingStoreWithNewRootKey(source *workloadapi.X509Source) <span class="cov0" title="0">{
        const fName = "BootstrapBackingStoreWithNewRootKey"

        log.Log().Info(fName, "msg",
                "Tombstone file does not exist. Bootstrapping SPIKE Nexus...")

        if !state.RootKeyZero() </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg",
                        "Recovery info found. Backing store already bootstrapped.",
                )
                return
        }</span>

        // Initialize the backend store before sending shards to the keepers.
        // SPIKE Keepers are our backup system, and they are not critical for system
        // operations. Initializing early allows SPIKE Nexus to serve before
        // keepers are hydrated.
        //
        // Security: Use a static byte array and pass it as a pointer to avoid
        // inadvertent copying / pass-by-value / memory allocation.
        <span class="cov0" title="0">var seed [32]byte
        // Security: Ensure the seed is zeroed out after use.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearRawBytes(&amp;seed)
        }</span>()

        <span class="cov0" title="0">if _, err := rand.Read(seed[:]); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>

        <span class="cov0" title="0">state.Initialize(&amp;seed)
        log.Log().Info(fName, "msg", "Initialized the backing store")

        // Compute Shamir shares out of the root key.
        rootShares := mustUpdateRecoveryInfo(&amp;seed)
        // Security: Ensure the seed is zeroed out after use.
        defer func() </span><span class="cov0" title="0">{
                for _, share := range rootShares </span><span class="cov0" title="0">{
                        share.Value.SetUint64(0)
                }</span>
        }()

        <span class="cov0" title="0">successfulKeepers := make(map[string]bool)
        keepers := env.Keepers()

        shamirShareCount := env.ShamirShares()
        if len(keepers) != shamirShareCount </span><span class="cov0" title="0">{
                log.FatalLn(
                        fName+": Keepers not configured correctly.",
                        "Share count:", shamirShareCount, "Keepers:", len(keepers),
                )
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Ensure to get a success response from ALL keepers eventually.
                exit := iterateKeepersToBootstrap(
                        keepers, rootShares, successfulKeepers, source,
                )
                if exit </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">log.Log().Info(fName, "msg", "Waiting for keepers to initialize")
                time.Sleep(env.RecoveryOperationPollInterval())</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "github.com/cloudflare/circl/group"
        "github.com/cloudflare/circl/secretsharing"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/internal/log"
)

type ShamirShard struct {
        Id    uint64
        Value *[32]byte
}

// RecoverRootKey reconstructs the original root key from a slice of ShamirShard.
// It uses Shamir's Secret Sharing scheme to recover the original secret.
//
// Parameters:
//   - ss []ShamirShard: A slice of ShamirShard structures, each containing
//     an ID and a pointer to a 32-byte value representing a secret share
//
// Returns:
//   - *[32]byte: A pointer to the reconstructed 32-byte root key
//
// The function will:
//   - Convert each ShamirShard into a properly formatted secretsharing.Share
//   - Use the IDs from the provided ShamirShards
//   - Retrieve the threshold from the environment
//   - Reconstruct the original secret using the secretsharing.Recover function
//   - Validate the recovered key has the correct length (32 bytes)
//   - Zero out all shares after use for security
//
// It will log a fatal error and exit if:
//   - Any share fails to unmarshal properly
//   - The recovery process fails
//   - The reconstructed key is nil
//   - The binary representation has an incorrect length
func RecoverRootKey(ss []ShamirShard) *[32]byte <span class="cov0" title="0">{
        const fName = "RecoverRootKey"

        g := group.P256
        shares := make([]secretsharing.Share, 0, len(ss))
        // Security: Ensure that the shares are zeroed out after the function returns:
        defer func() </span><span class="cov0" title="0">{
                for _, s := range shares </span><span class="cov0" title="0">{
                        s.ID.SetUint64(0)
                        s.Value.SetUint64(0)
                }</span>
        }()

        // Process all provided shares
        <span class="cov0" title="0">for _, shamirShard := range ss </span><span class="cov0" title="0">{
                // Create a new share with sequential ID (starting from 1):
                share := secretsharing.Share{
                        ID:    g.NewScalar(),
                        Value: g.NewScalar(),
                }

                // Set ID
                share.ID.SetUint64(shamirShard.Id)

                // Unmarshal the binary data
                err := share.Value.UnmarshalBinary(shamirShard.Value[:])
                if err != nil </span><span class="cov0" title="0">{
                        log.FatalLn(fName + ": Failed to unmarshal share: " + err.Error())
                }</span>

                <span class="cov0" title="0">shares = append(shares, share)</span>
        }

        // Recover the secret
        // The first parameter to Recover is threshold-1
        // We need the threshold from the environment
        <span class="cov0" title="0">threshold := env.ShamirThreshold()
        reconstructed, err := secretsharing.Recover(uint(threshold-1), shares)
        if err != nil </span><span class="cov0" title="0">{
                // Security: Reset shares.
                // Defer won't get called because `log.FatalLn` terminates the program.
                for _, s := range shares </span><span class="cov0" title="0">{
                        s.ID.SetUint64(0)
                        s.Value.SetUint64(0)
                }</span>

                <span class="cov0" title="0">log.FatalLn(fName + ": Failed to recover: " + err.Error())</span>
        }

        <span class="cov0" title="0">if reconstructed == nil </span><span class="cov0" title="0">{
                // Security: Reset shares.
                // Defer won't get called because `log.FatalLn` terminates the program.
                for _, s := range shares </span><span class="cov0" title="0">{
                        s.ID.SetUint64(0)
                        s.Value.SetUint64(0)
                }</span>

                <span class="cov0" title="0">log.FatalLn(fName + ": Failed to reconstruct the root key")</span>
        }

        <span class="cov0" title="0">if reconstructed != nil </span><span class="cov0" title="0">{
                binaryRec, err := reconstructed.MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        // Security: Zero out:
                        reconstructed.SetUint64(0)

                        log.FatalLn(fName + ": Failed to marshal: " + err.Error())
                        return &amp;[32]byte{}
                }</span>

                <span class="cov0" title="0">if len(binaryRec) != 32 </span><span class="cov0" title="0">{
                        log.FatalLn(fName + ": Reconstructed root key has incorrect length")
                        return &amp;[32]byte{}
                }</span>

                <span class="cov0" title="0">var result [32]byte
                copy(result[:], binaryRec)
                // Security: Zero out temporary variables before the function exits.
                mem.ClearBytes(binaryRec)

                return &amp;result</span>
        }

        <span class="cov0" title="0">return &amp;[32]byte{}</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "github.com/cloudflare/circl/group"
        shamir "github.com/cloudflare/circl/secretsharing"
        "github.com/spiffe/spike-sdk-go/crypto"

        "github.com/spiffe/spike/app/nexus/internal/env"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
)

// sanityCheck verifies that a set of secret shares can correctly reconstruct
// the original secret. It performs this verification by attempting to recover
// the secret using the minimum required number of shares and comparing the
// result with the original secret.
//
// Parameters:
//   - secret group.Scalar: The original secret to verify against
//   - shares []shamir.Share: The generated secret shares to verify
//
// The function will:
//   - Calculate the threshold (t) from the environment configuration
//   - Attempt to reconstruct the secret using exactly t+1 shares
//   - Compare the reconstructed secret with the original
//   - Zero out the reconstructed secret regardless of success or failure
//
// If the verification fails, the function will:
//   - Log a fatal error and exit if recovery fails
//   - Log a fatal error and exit if the recovered secret doesn't match the
//     original
//
// Security:
//   - The reconstructed secret is always zeroed out to prevent memory leaks
//   - In case of fatal errors, the reconstructed secret is explicitly zeroed
//     before logging since deferred functions won't run after log.FatalLn
func sanityCheck(secret group.Scalar, shares []shamir.Share) <span class="cov0" title="0">{
        const fName = "sanityCheck"

        t := uint(env.ShamirThreshold() - 1) // Need t+1 shares to reconstruct

        reconstructed, err := shamir.Recover(t, shares[:env.ShamirThreshold()])
        // Security: Ensure that the secret is zeroed out if the check fails.
        defer func() </span><span class="cov0" title="0">{
                if reconstructed == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">reconstructed.SetUint64(0)</span>
        }()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // deferred will not run in a fatal crash.
                reconstructed.SetUint64(0)

                log.FatalLn(fName + ": Failed to recover: " + err.Error())
        }</span>
        <span class="cov0" title="0">if !secret.IsEqual(reconstructed) </span><span class="cov0" title="0">{
                // deferred will not run in a fatal crash.
                reconstructed.SetUint64(0)

                log.FatalLn(fName + ": Recovered secret does not match original")
        }</span>
}

// computeShares generates a set of Shamir secret shares from the root key.
// The function uses a deterministic random reader seeded with the root key,
// which ensures that the same shares are always generated for a given root key.
// This deterministic behavior is crucial for the system's reliability, allowing
// shares to be recomputed as needed while maintaining consistency.
func computeShares() (group.Scalar, []shamir.Share) <span class="cov0" title="0">{
        const fName = "computeShares"

        log.Log().Info(fName, "msg", "Computing Shamir shares")

        state.LockRootKey()
        defer state.UnlockRootKey()
        rk := state.RootKeyNoLock()

        // Initialize parameters
        g := group.P256
        t := uint(env.ShamirThreshold() - 1) // Need t+1 shares to reconstruct
        n := uint(env.ShamirShares())        // Total number of shares

        log.Log().Info(fName, "t", t, "n", n)

        // Create a secret from our 32-byte key:
        secret := g.NewScalar()

        if err := secret.UnmarshalBinary(rk[:]); err != nil </span><span class="cov0" title="0">{
                log.FatalLn(fName + ": Failed to unmarshal key: %v" + err.Error())
        }</span>

        // To compute identical shares, we need an identical seed for the random
        // reader. Using `finalKey` for seed is secure because Shamir Secret Sharing
        // algorithm's security does not depend on the random seed; it depends on
        // the shards being securely kept secret.
        // If we use `random.Read` instead, then synchronizing shards after Nexus
        // crashes will be cumbersome and prone to edge-case failures.
        <span class="cov0" title="0">reader := crypto.NewDeterministicReader(rk[:])
        ss := shamir.New(reader, t, secret)

        log.Log().Info(fName, "msg", "Generated Shamir shares")

        computedShares := ss.Share(n)

        // secret is a pointer type; ss.Share(n) is a slice
        // shares will have monotonically increasing IDs, starting from 1.
        return secret, computedShares</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "encoding/json"
        "net/url"

        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiUrl "github.com/spiffe/spike-sdk-go/api/url"
        network "github.com/spiffe/spike-sdk-go/net"
        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

func shardUrl(keeperApiRoot string) string <span class="cov0" title="0">{
        const fName = "shardUrl"

        u, err := url.JoinPath(keeperApiRoot, string(apiUrl.SpikeKeeperUrlShard))
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(
                        fName, "msg", "Failed to join path", "url", keeperApiRoot,
                )
                return ""
        }</span>
        <span class="cov0" title="0">return u</span>
}

func shardResponse(source *workloadapi.X509Source, u string) []byte <span class="cov0" title="0">{
        const fName = "shardResponse"

        shardRequest := reqres.ShardRequest{}
        md, err := json.Marshal(shardRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to marshal request",
                        "err", err)
                return []byte{}
        }</span>

        <span class="cov0" title="0">client, err := network.CreateMtlsClientWithPredicate(
                source,
                func(peerId string) bool </span><span class="cov0" title="0">{
                        return spiffeid.IsKeeper(env.TrustRootForKeeper(), peerId)
                }</span>,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to create mTLS client",
                        "err", err)
                return []byte{}
        }</span>

        <span class="cov0" title="0">data, err := net.Post(client, u, md)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to post",
                        "err", err)
        }</span>

        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "No data")
                return []byte{}
        }</span>

        <span class="cov0" title="0">return data</span>
}

func unmarshalShardResponse(data []byte) *reqres.ShardResponse <span class="cov0" title="0">{
        const fName = "unmarshalShardResponse"

        var res reqres.ShardResponse
        err := json.Unmarshal(data, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg",
                        "Failed to unmarshal response", "err", err)
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;res</span>
}

func shardContributionResponse(
        u string, contribution *[]byte, source *workloadapi.X509Source,
) []byte <span class="cov0" title="0">{
        const fName = "shardContributionResponse"

        client, err := network.CreateMtlsClientWithPredicate(source,
                func(peerId string) bool </span><span class="cov0" title="0">{
                        return spiffeid.IsKeeper(env.TrustRootForKeeper(), peerId)
                }</span>,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to create mTLS client",
                        "err", err)
                return []byte{}
        }</span>

        <span class="cov0" title="0">zeroed := true
        for i := range *contribution </span><span class="cov0" title="0">{
                if (*contribution)[i] != 0 </span><span class="cov0" title="0">{
                        zeroed = false
                        break</span>
                }
        }

        <span class="cov0" title="0">if zeroed </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "All zeros")
                return []byte{}
        }</span>

        <span class="cov0" title="0">if len(*contribution) != 32 </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "invalid contribution length",
                        "len", len(*contribution))

                // Do not reset `contribution` as this function does not "own" it.

                return []byte{}
        }</span>

        <span class="cov0" title="0">var c [32]byte
        copy(c[:], *contribution)
        // Security: Ensure that the temporary variable is zeroed out before
        // the function exits.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearRawBytes(&amp;c)
        }</span>()

        <span class="cov0" title="0">scr := reqres.ShardContributionRequest{
                Shard: &amp;c,
        }
        // Security: Ensure that the struct field is zeroed out before the function
        // exits.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearRawBytes(scr.Shard)
        }</span>()

        <span class="cov0" title="0">md, err := json.Marshal(scr)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to marshal request",
                        "err", err)
                return []byte{}
        }</span>
        // Security: Ensure that the md is zeroed out before the function exits.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                mem.ClearBytes(md)
        }</span>()

        <span class="cov0" title="0">data, err := net.Post(client, u, md)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg",
                        "Failed to post",
                        "err", err)
        }</span>

        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "No data")
                return []byte{}
        }</span>

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package recovery

import (
        "encoding/json"
        "github.com/spiffe/spike/app/nexus/internal/env"
        "net/url"
        "strconv"

        "github.com/cloudflare/circl/group"
        "github.com/cloudflare/circl/secretsharing"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiUrl "github.com/spiffe/spike-sdk-go/api/url"
        network "github.com/spiffe/spike-sdk-go/net"
        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// mustUpdateRecoveryInfo updates the recovery information by setting a new root
// key and computing new shares. It returns the computed shares.
//
// The function sets the provided root key in the state, computes shares from
// the root secret, performs a sanity check on the computed shares, and ensures
// that temporary variables containing sensitive information are zeroed out
// after use.
//
// This is a critical security function that handles sensitive key material.
//
// Parameters:
//   - rk: A pointer to a 32-byte array containing the new root key
//
// Returns:
//   - []secretsharing.Share: The computed shares for the root secret
func mustUpdateRecoveryInfo(rk *[32]byte) []secretsharing.Share <span class="cov0" title="0">{
        const fName = "mustUpdateRecoveryInfo"
        log.Log().Info(fName, "msg", "Updating recovery info")

        // Save recovery information.
        state.SetRootKey(rk)

        rootSecret, rootShares := computeShares()
        sanityCheck(rootSecret, rootShares)
        // Security: Ensure that temporary variables are zeroed out.
        defer func() </span><span class="cov0" title="0">{
                rootSecret.SetUint64(0)
        }</span>()

        <span class="cov0" title="0">return rootShares</span>
}

// sendShardsToKeepers distributes shares of the root key to all keeper nodes.
// Note that we recompute shares for each keeper rather than computing them once
// and distributing them. This is safe because:
//  1. computeShares() uses a deterministic random reader seeded with the
//     root key
//  2. Given the same root key, it will always produce identical shares
//  3. findShare() ensures each keeper receives its designated share
//     This approach simplifies the code flow and maintains consistency across
//     potential system restarts or failures.
//
// Note that sendSharesToKeepers optimistically moves on to the next SPIKE
// Keeper in the list on error. This is okay, because SPIKE Nexus may not
// need all keepers to be healthy all at once, and since we periodically
// send shards to keepers, provided there is no configuration mistake,
// all SPIKE Keepers will get their shards eventually.
func sendShardsToKeepers(
        source *workloadapi.X509Source, keepers map[string]string,
) <span class="cov0" title="0">{
        const fName = "sendShardsToKeepers"

        for keeperId, keeperApiRoot := range keepers </span><span class="cov0" title="0">{
                u, err := url.JoinPath(
                        keeperApiRoot, string(apiUrl.SpikeKeeperUrlContribute),
                )

                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(
                                fName, "msg", "Failed to join path", "url", keeperApiRoot,
                        )
                        continue</span>
                }

                <span class="cov0" title="0">client, err := network.CreateMtlsClientWithPredicate(
                        source, func(peerId string) bool </span><span class="cov0" title="0">{
                                return spiffeid.IsKeeper(env.TrustRootForKeeper(), peerId)
                        }</span>,
                )

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(fName,
                                "msg", "Failed to create mTLS client",
                                "err", err)
                        continue</span>
                }

                <span class="cov0" title="0">if state.RootKeyZero() </span><span class="cov0" title="0">{
                        log.Log().Warn(fName, "msg", "rootKey is zero; moving on...")
                        continue</span>
                }

                <span class="cov0" title="0">rootSecret, rootShares := computeShares()
                sanityCheck(rootSecret, rootShares)

                var share secretsharing.Share
                for _, sr := range rootShares </span><span class="cov0" title="0">{
                        kid, err := strconv.Atoi(keeperId)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Log().Warn(
                                        fName, "msg", "Failed to convert keeper id to int", "err", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if sr.ID.IsEqual(group.P256.NewScalar().SetUint64(uint64(kid))) </span><span class="cov0" title="0">{
                                share = sr
                                break</span>
                        }
                }

                <span class="cov0" title="0">if share.ID.IsZero() </span><span class="cov0" title="0">{
                        log.Log().Warn(fName,
                                "msg", "Failed to find share for keeper", "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">rootSecret.SetUint64(0)

                contribution, err := share.Value.MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(fName, "msg", "Failed to marshal share",
                                "err", err, "keeper_id", keeperId)

                        // Security: Ensure that the contribution is zeroed out before
                        // the next iteration.
                        mem.ClearBytes(contribution)

                        // Security: Ensure that the share is zeroed out before
                        // the next iteration.
                        share.Value.SetUint64(0)

                        // Security: Ensure that the rootShares are zeroed out before
                        // the function returns.
                        for i := range rootShares </span><span class="cov0" title="0">{
                                rootShares[i].Value.SetUint64(0)
                        }</span>

                        <span class="cov0" title="0">log.Log().Warn(fName,
                                "msg", "Failed to marshal share",
                                "err", err, "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">if len(contribution) != 32 </span><span class="cov0" title="0">{
                        // Security: Ensure that the contribution is zeroed out before
                        // the next iteration.
                        //
                        // Note that you cannot do `mem.ClearRawBytes(contribution)` because
                        // the contribution is a slice, not a struct; we use `mem.ClearBytes()`
                        // instead.
                        mem.ClearBytes(contribution)

                        // Security: Ensure that the share is zeroed out before
                        // the next iteration.
                        share.Value.SetUint64(0)

                        // Security: Ensure that the rootShares are zeroed out before
                        // the function returns.
                        for i := range rootShares </span><span class="cov0" title="0">{
                                rootShares[i].Value.SetUint64(0)
                        }</span>

                        <span class="cov0" title="0">log.Log().Warn(fName,
                                "msg", "invalid contribution length",
                                "len", len(contribution), "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">scr := reqres.ShardContributionRequest{}

                shard := new([32]byte)
                // Security: shard is intentionally binary (instead of string) for
                // better memory management. Do not change its data type.
                copy(shard[:], contribution)
                scr.Shard = shard

                md, err := json.Marshal(scr)

                // Security: Erase scr.Shard when no longer in use.
                mem.ClearRawBytes(scr.Shard)

                // Security: Ensure that the contribution is zeroed out before
                // the next iteration.
                mem.ClearBytes(contribution)

                // Security: Ensure that the share is zeroed out before
                // the next iteration.
                share.Value.SetUint64(0)

                // Security: Ensure that the rootShares are zeroed out before
                // the function returns.
                for i := range rootShares </span><span class="cov0" title="0">{
                        rootShares[i].Value.SetUint64(0)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(fName,
                                "msg", "Failed to marshal request",
                                "err", err, "keeper_id", keeperId)
                        continue</span>
                }

                <span class="cov0" title="0">_, err = net.Post(client, u, md)
                // Security: Ensure that the md is zeroed out before
                // the next iteration.
                mem.ClearBytes(md)

                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Warn(fName, "msg",
                                "Failed to post",
                                "err", err, "keeper_id", keeperId)
                        continue</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/spiffe/spike-sdk-go/net"

        "github.com/spiffe/spike/app/nexus/internal/env"
        http "github.com/spiffe/spike/app/nexus/internal/route/base"
        "github.com/spiffe/spike/internal/log"
        routing "github.com/spiffe/spike/internal/net"
)

// Serve initializes and starts a TLS-secured HTTP server for the given
// application.
//
// Serve uses the provided X509Source for TLS authentication and configures the
// server with the specified HTTP routes. It will listen on the port specified
// by the TLS port environment variable. If the server fails to start, it logs a
// fatal error and terminates the application.
//
// Parameters:
//   - appName: A string identifier for the application, used in error messages
//   - source: An X509Source that provides TLS certificates for the server
//
// The function does not return unless an error occurs, in which case it calls
// log.FatalF and terminates the program.
func Serve(appName string, source *workloadapi.X509Source) <span class="cov0" title="0">{
        if err := net.Serve(
                source,
                func() </span><span class="cov0" title="0">{ routing.HandleRoute(http.Route) }</span>,
                env.TlsPort(),
        ); err != nil <span class="cov0" title="0">{
                log.FatalF("%s: Failed to serve: %s\n", appName, err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"
        "time"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RoutePutPolicy handles HTTP PUT requests for creating new policies.
// It processes the request body to create a policy with the specified name,
// SPIFFE ID pattern, path pattern, and permissions.
//
// The function expects a JSON request body containing:
//   - Name: policy name
//   - SpiffeIdPattern: SPIFFE ID matching pattern
//   - PathPattern: path matching pattern
//   - Permissions: set of allowed permissions
//
// On success, it returns a JSON response with the created policy's ID.
// On failure, it returns an appropriate error response with status code.
//
// Parameters:
//   - w: HTTP response writer for sending the response
//   - r: HTTP request containing the policy creation data
//   - audit: Audit entry for logging the policy creation action
//
// Returns:
//   - error: nil on successful policy creation, error otherwise
//
// Example request body:
//
//        {
//            "name": "example-policy",
//            "spiffe_id_pattern": "spiffe://example.org/*/service",
//            "path_pattern": "/api/*",
//            "permissions": ["read", "write"]
//        }
//
// Example success response:
//
//        {
//            "id": "policy-123"
//        }
//
// Example error response:
//
//        {
//            "err": "Internal server error"
//        }
func RoutePutPolicy(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routePutPolicy"
        log.AuditRequest(fName, r, audit, log.AuditCreate)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.PolicyCreateRequest, reqres.PolicyCreateResponse](
                requestBody, w,
                reqres.PolicyCreateResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">err := guardPutPolicyRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">name := request.Name
        spiffeIdPattern := request.SpiffeIdPattern
        pathPattern := request.PathPattern
        permissions := request.Permissions

        policy, err := state.CreatePolicy(data.Policy{
                Id:              "",
                Name:            name,
                SpiffeIdPattern: spiffeIdPattern,
                PathPattern:     pathPattern,
                Permissions:     permissions,
                CreatedAt:       time.Time{},
                CreatedBy:       "",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg", "Failed to create policy", "err", err)

                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrInternal,
                }, w)

                net.Respond(http.StatusInternalServerError, responseBody, w)
                log.Log().Error(fName, "msg", data.ErrInternal)

                return err
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                Id: policy.Id,
        }, w)

        net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardPutPolicyRequest(
        request reqres.PolicyCreateRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        name := request.Name
        spiffeIdPattern := request.SpiffeIdPattern
        pathPattern := request.PathPattern
        permissions := request.Permissions

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        // Request "write" access to the ACL system for the SPIFFE ID.
        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), "spike/system/acl",
                []data.PolicyPermission{data.PermissionWrite},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateName(name)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeIdPattern(spiffeIdPattern)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePathPattern(pathPattern)
        if err != nil </span><span class="cov0" title="0">{
                responseBody :=
                        net.MarshalBody(reqres.PolicyCreateResponse{
                                Err: data.ErrBadInput,
                        }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePermissions(permissions)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyCreateResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteDeletePolicy handles HTTP DELETE requests to remove existing policies.
// It processes the request body to delete a policy specified by its ID.
//
// The function expects a JSON request body containing:
//   - Id: unique identifier of the policy to delete
//
// On success, it returns an empty JSON response with HTTP 200 status.
// On failure, it returns an appropriate error response with status code.
//
// Parameters:
//   - w: HTTP response writer for sending the response
//   - r: HTTP request containing the policy ID to delete
//   - audit: Audit entry for logging the policy deletion action
//
// Returns:
//   - error: nil on successful policy deletion, error otherwise
//
// Example request body:
//
//        {
//            "id": "policy-123"
//        }
//
// Example success response:
//
//        {}
//
// Example error response:
//
//        {
//            "err": "Internal server error"
//        }
//
// Possible errors:
//   - Failed to read request body
//   - Failed to parse request body
//   - Failed to marshal response body
//   - Failed to delete policy (internal server error)
func RouteDeletePolicy(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeDeletePolicy"
        log.AuditRequest(fName, r, audit, log.AuditDelete)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.PolicyDeleteRequest, reqres.PolicyDeleteResponse](
                requestBody, w,
                reqres.PolicyDeleteResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">policyId := request.Id

        err := guardDeletePolicyRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = state.DeletePolicy(policyId)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg", "Failed to delete policy", "err", err)

                responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{
                        Err: data.ErrInternal,
                }, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return errors.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusInternalServerError, responseBody, w)
                log.Log().Error(fName, "msg", data.ErrInternal)
                return err</span>
        }

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{}, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardDeletePolicyRequest(
        request reqres.PolicyDeleteRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        policyId := request.Id

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePolicyId(policyId)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{
                        Err: data.ErrBadInput,
                }, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return apiErr.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput</span>
        }

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), "spike/system/acl",
                []data.PolicyPermission{data.PermissionWrite},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteListPolicies handles HTTP requests to retrieve all existing policies.
// It returns a list of all policies in the system, including their IDs, names,
// SPIFFE ID patterns, path patterns, and permissions.
//
// The function expects an empty JSON request body ({}) and returns an array
// of policy objects.
//
// Parameters:
//   - w: HTTP response writer for sending the response
//   - r: HTTP request for the policy listing operation
//   - audit: Audit entry for logging the policy list action
//
// Returns:
//   - error: nil on successful retrieval, error otherwise
//
// Example request body:
//
//        {}
//
// Example success response:
//
//        {
//            "policies": [
//                {
//                    "id": "policy-123",
//                    "name": "example-policy",
//                    "spiffe_id_pattern": "spiffe://example.org/*/service",
//                    "path_pattern": "/api/*",
//                    "permissions": ["read", "write"],
//                    "created_at": "2024-01-01T00:00:00Z",
//                    "created_by": "user-abc"
//                }
//                // ... additional policies
//            ]
//        }
//
// Example error response:
//
//        {
//            "err": "Internal server error"
//        }
//
// Possible errors:
//   - Failed to read request body
//   - Failed to parse request body
//   - Failed to marshal response body
func RouteListPolicies(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        fName := "routeListPolicies"
        log.AuditRequest(fName, r, audit, log.AuditList)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.PolicyListRequest, reqres.PolicyListResponse](
                requestBody, w,
                reqres.PolicyListResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardListPolicyRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use ListPoliciesBySpiffeId if spiffeIdPattern is provided, otherwise list all
        <span class="cov0" title="0">var policies []data.Policy
        if request.SpiffeIdPattern != "" </span><span class="cov0" title="0">{
                policies = state.ListPoliciesBySpiffeId(request.SpiffeIdPattern)
        }</span> else<span class="cov0" title="0"> {
                policies = state.ListPolicies()
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.PolicyListResponse{
                Policies: policies,
        }, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardListPolicyRequest(
        _ reqres.PolicyListRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), "spike/system/acl",
                []data.PolicyPermission{data.PermissionList},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "errors"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteGetPolicy handles HTTP requests to retrieve a specific policy by its ID.
// It processes the request body to fetch detailed information about a single
// policy.
//
// The function expects a JSON request body containing:
//   - Id: unique identifier of the policy to retrieve
//
// On success, it returns the complete policy object. If the policy is not
// found, it returns a "not found" error. For other errors, it returns an
// internal server error.
//
// Parameters:
//   - w: HTTP response writer for sending the response
//   - r: HTTP request containing the policy ID to retrieve
//   - audit: Audit entry for logging the policy read action
//
// Returns:
//   - error: nil on successful retrieval or policy not found, error on system
//     failures
//
// Example request body:
//
//        {
//            "id": "policy-123"
//        }
//
// Example success response:
//
//        {
//            "policy": {
//                "id": "policy-123",
//                "name": "example-policy",
//                "spiffe_id_pattern": "spiffe://example.org/*/service",
//                "path_pattern": "/api/*",
//                "permissions": ["read", "write"],
//                "created_at": "2024-01-01T00:00:00Z",
//                "created_by": "user-abc"
//            }
//        }
//
// Example not found response:
//
//        {
//            "err": "not_found"
//        }
//
// Example error response:
//
//        {
//            "err": "Internal server error"
//        }
//
// HTTP Status Codes:
//   - 200: Policy found and returned successfully
//   - 404: Policy not found
//   - 500: Internal server error
//
// Possible errors:
//   - Failed to read request body
//   - Failed to parse request body
//   - Failed to marshal response body
//   - Policy not found
//   - Internal server error during policy retrieval
func RouteGetPolicy(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeGetPolicy"
        log.AuditRequest(fName, r, audit, log.AuditRead)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return apiErr.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.PolicyReadRequest, reqres.PolicyReadResponse](
                requestBody, w,
                reqres.PolicyReadResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return apiErr.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardReadPolicyRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">policyId := request.Id

        policy, err := state.GetPolicy(policyId)
        if err == nil </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Policy found")
        }</span> else<span class="cov0" title="0"> if errors.Is(err, state.ErrPolicyNotFound) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Policy not found")

                res := reqres.PolicyReadResponse{Err: data.ErrNotFound}
                responseBody := net.MarshalBody(res, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return apiErr.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusNotFound, responseBody, w)
                log.Log().Info(fName, "msg", "Policy not found: returning nil")
                return nil</span>
        } else<span class="cov0" title="0"> {
                // I should not be here, normally.

                log.Log().Info(fName, "msg", "Failed to retrieve policy", "err", err)

                responseBody := net.MarshalBody(reqres.PolicyReadResponse{
                        Err: data.ErrInternal}, w,
                )
                if responseBody == nil </span><span class="cov0" title="0">{
                        return apiErr.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusInternalServerError, responseBody, w)
                log.Log().Warn(fName, "msg", data.ErrInternal)
                return err</span>
        }

        <span class="cov0" title="0">responseBody := net.MarshalBody(
                reqres.PolicyReadResponse{Policy: policy}, w,
        )
        if responseBody == nil </span><span class="cov0" title="0">{
                return apiErr.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardReadPolicyRequest(
        request reqres.PolicyReadRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        policyId := request.Id

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePolicyId(policyId)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyReadResponse{
                        Err: data.ErrBadInput,
                }, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return apiErr.ErrMarshalFailure
                }</span>
                <span class="cov0" title="0">return apiErr.ErrInvalidInput</span>
        }

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), "spike/system/acl",
                []data.PolicyPermission{data.PermissionRead},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.PolicyReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package base contains the fundamental building blocks and core functions
// for handling HTTP requests in the SPIKE Nexus application. It provides
// the routing logic to map API actions and URL paths to their respective
// handlers while ensuring seamless request processing and response generation.
// This package serves as a central point for managing incoming API calls
// and delegating them to the correct functional units based on specified rules.
package base

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/url"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/route/acl/policy"
        "github.com/spiffe/spike/app/nexus/internal/route/operator"
        "github.com/spiffe/spike/app/nexus/internal/route/secret"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// Route handles all incoming HTTP requests by dynamically selecting and
// executing the appropriate handler based on the request path and HTTP method.
// It uses a factory function to create the specific handler for the given URL
// path and HTTP method combination.
//
// Parameters:
//   - w: The HTTP ResponseWriter to write the response to
//   - r: The HTTP Request containing the client's request details
func Route(
        w http.ResponseWriter, r *http.Request, a *log.AuditEntry,
) error <span class="cov0" title="0">{
        return net.RouteFactory[url.ApiAction](
                url.ApiUrl(r.URL.Path),
                url.ApiAction(r.URL.Query().Get(url.KeyApiAction)),
                r.Method,
                func(a url.ApiAction, p url.ApiUrl) net.Handler </span><span class="cov0" title="0">{
                        emptyRootKey := state.RootKeyZero()
                        inMemoryMode := env.BackendStoreType() == env.Memory
                        emergencyAction := p == url.SpikeNexusUrlOperatorRecover ||
                                p == url.SpikeNexusUrlOperatorRestore
                        canBypassRootKeyValidation := inMemoryMode || emergencyAction
                        rootKeyValidationRequired := !canBypassRootKeyValidation

                        if rootKeyValidationRequired &amp;&amp; emptyRootKey </span><span class="cov0" title="0">{
                                return net.NotReady
                        }</span>

                        <span class="cov0" title="0">switch </span>{
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeNexusUrlSecrets:<span class="cov0" title="0">
                                return secret.RoutePutSecret</span>
                        case a == url.ActionGet &amp;&amp; p == url.SpikeNexusUrlSecrets:<span class="cov0" title="0">
                                return secret.RouteGetSecret</span>
                        case a == url.ActionDelete &amp;&amp; p == url.SpikeNexusUrlSecrets:<span class="cov0" title="0">
                                return secret.RouteDeleteSecret</span>
                        case a == url.ActionUndelete &amp;&amp; p == url.SpikeNexusUrlSecrets:<span class="cov0" title="0">
                                return secret.RouteUndeleteSecret</span>
                        case a == url.ActionList &amp;&amp; p == url.SpikeNexusUrlSecrets:<span class="cov0" title="0">
                                return secret.RouteListPaths</span>
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeNexusUrlPolicy:<span class="cov0" title="0">
                                return policy.RoutePutPolicy</span>
                        case a == url.ActionGet &amp;&amp; p == url.SpikeNexusUrlPolicy:<span class="cov0" title="0">
                                return policy.RouteGetPolicy</span>
                        case a == url.ActionDelete &amp;&amp; p == url.SpikeNexusUrlPolicy:<span class="cov0" title="0">
                                return policy.RouteDeletePolicy</span>
                        case a == url.ActionList &amp;&amp; p == url.SpikeNexusUrlPolicy:<span class="cov0" title="0">
                                return policy.RouteListPolicies</span>
                        case a == url.ActionGet &amp;&amp; p == url.SpikeNexusUrlSecretsMetadata:<span class="cov0" title="0">
                                return secret.RouteGetSecretMetadata</span>
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeNexusUrlOperatorRestore:<span class="cov0" title="0">
                                return operator.RouteRestore</span>
                        case a == url.ActionDefault &amp;&amp; p == url.SpikeNexusUrlOperatorRecover:<span class="cov0" title="0">
                                return operator.RouteRecover</span>
                        default:<span class="cov0" title="0">
                                return net.Fallback</span>
                        }
                })(w, r, a)
}
</pre>
		
		<pre class="file" id="file38" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/initialization/recovery"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteRecover handles HTTP requests for recovering pilot recovery shards.
//
// This function processes HTTP requests to retrieve recovery shards needed for
// a recovery operation. It reads and validates the request, retrieves the first
// two recovery shards from the pilot recovery system, and returns them in the
// response.
//
// Parameters:
//   - w http.ResponseWriter: The HTTP response writer to write the response to.
//   - r *http.Request: The incoming HTTP request.
//   - audit *log.AuditEntry: An audit entry for logging the request.
//
// Returns:
//   - error: An error if one occurs during processing, nil otherwise.
//
// The function will return various errors in the following cases:
//   - errors.ErrReadFailure: If the request body cannot be read.
//   - errors.ErrParseFailure: If the request body cannot be parsed.
//   - errors.ErrNotFound: If fewer than 2 recovery shards are available.
//   - Any error returned by guardRecoverRequest: For request validation
//     failures.
//
// On success, the function responds with HTTP 200 OK and the first two recovery
// shards in the response body.
func RouteRecover(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeRecover"
        log.AuditRequest(fName, r, audit, log.AuditCreate)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg", "requestBody is nil")
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.RecoverRequest, reqres.RecoverResponse](
                requestBody, w,
                reqres.RecoverResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName, "msg", "request is nil")
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardRecoverRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "request is valid. Recovery shards requested.")
        shards := recovery.NewPilotRecoveryShards()

        // Security: reset shards before the function exits.
        defer func() </span><span class="cov0" title="0">{
                for i := range shards </span><span class="cov0" title="0">{
                        mem.ClearRawBytes(shards[i])
                }</span>
        }()

        <span class="cov0" title="0">if len(shards) &lt; env.ShamirThreshold() </span><span class="cov0" title="0">{
                log.Log().Error(fName, "msg", "not enough shards. Exiting.")
                return errors.ErrNotFound
        }</span>

        // Track seen indices to check for duplicates
        <span class="cov0" title="0">seenIndices := make(map[int]bool)

        for idx, shard := range shards </span><span class="cov0" title="0">{
                if seenIndices[idx] </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "duplicate index. Exiting.")
                        // Duplicate index.
                        return errors.ErrInvalidInput
                }</span>

                // We cannot check for duplicate values, because although it's
                // astronomically unlikely, there is still a possibility of two
                // different indices having the same shard value.

                <span class="cov0" title="0">seenIndices[idx] = true

                // Check for nil pointers
                if shard == nil </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "nil shard. Exiting.")
                        return errors.ErrInvalidInput
                }</span>

                // Check for empty shards (all zeros)
                <span class="cov0" title="0">zeroed := true
                for _, b := range *shard </span><span class="cov0" title="0">{
                        if b != 0 </span><span class="cov0" title="0">{
                                zeroed = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if zeroed </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "zeroed shard. Exiting.")
                        return errors.ErrInvalidInput
                }</span>

                // Verify shard index is within valid range:
                <span class="cov0" title="0">if idx &lt; 1 || idx &gt; env.ShamirShares() </span><span class="cov0" title="0">{
                        log.Log().Error(fName, "msg", "invalid index. Exiting.")
                        return errors.ErrInvalidInput
                }</span>
        }

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.RecoverResponse{
                Shards: shards,
        }, w)
        // Security: Clean up response body before exit.
        defer func() </span><span class="cov0" title="0">{
                mem.ClearBytes(responseBody)
        }</span>()

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "github.com/spiffe/spike/app/nexus/internal/env"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/internal/net"
)

func guardRecoverRequest(
        _ reqres.RecoverRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        peerSpiffeId, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">if !spiffeid.IsPilotRecover(env.TrustRootForPilot(), peerSpiffeId.String()) </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "net/http"
        "sync"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/security/mem"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/initialization/recovery"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

var (
        shards      []recovery.ShamirShard
        shardsMutex sync.RWMutex
)

// RouteRestore handles HTTP requests for restoring a system using recovery
// shards.
//
// This function processes requests to contribute a recovery shard to the
// restoration process. It validates the incoming shard, adds it to the
// collection, and triggers the full restoration once all expected shards have
// been collected.
//
// Parameters:
//   - w http.ResponseWriter: The HTTP response writer to write the response to.
//   - r *http.Request: The incoming HTTP request.
//   - audit *log.AuditEntry: An audit entry for logging the request.
//
// Returns:
//   - error: An error if one occurs during processing, nil otherwise.
//
// The function will return various errors in the following cases:
//   - errors.ErrReadFailure: If the request body cannot be read.
//   - errors.ErrParseFailure: If the request body cannot be parsed.
//   - errors.ErrMarshalFailure: If the response body cannot be marshaled.
//   - Any error returned by guardRestoreRequest: For request validation
//     failures.
//
// The function responds with:
//   - HTTP 400 Bad Request: If all required shards have already been collected
//     or if the provided shard is invalid.
//   - HTTP 200 OK: If the shard is successfully added, including status
//     information about the restoration progress.
//
// When the last required shard is added, the function automatically triggers
// the restoration process using RestoreBackingStoreUsingPilotShards.
func RouteRestore(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeRestore"

        log.AuditRequest(fName, r, audit, log.AuditCreate)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.RestoreRequest, reqres.RestoreResponse](
                requestBody, w,
                reqres.RestoreResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardRestoreRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">shardsMutex.Lock()
        defer shardsMutex.Unlock()

        // Check if we already have enough shards
        currentShardCount := len(shards)

        if currentShardCount &gt;= env.ShamirThreshold() </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        RestorationStatus: data.RestorationStatus{
                                ShardsCollected: currentShardCount,
                                ShardsRemaining: 0,
                                Restored:        true,
                        },
                        Err: data.ErrBadInput,
                }, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return errors.ErrMarshalFailure
                }</span>
                <span class="cov0" title="0">net.Respond(http.StatusBadRequest, responseBody, w)
                return nil</span>
        }

        <span class="cov0" title="0">for _, shard := range shards </span><span class="cov0" title="0">{
                if int(shard.Id) != request.Id </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Duplicate shard found.

                <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.RestoreResponse{
                        RestorationStatus: data.RestorationStatus{
                                ShardsCollected: currentShardCount,
                                ShardsRemaining: env.ShamirThreshold() - currentShardCount,
                                Restored:        currentShardCount == env.ShamirThreshold(),
                        },
                        Err: data.ErrBadInput,
                }, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return errors.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusBadRequest, responseBody, w)
                return nil</span>
        }

        <span class="cov0" title="0">shards = append(shards, recovery.ShamirShard{
                Id:    uint64(request.Id),
                Value: request.Shard,
        })

        currentShardCount = len(shards)

        // Note: We cannot clear request.Shard because it's a pointer type,
        // and we need it later in the "restore" operation.
        // RouteRestore cleans this up, when it is no longer needed.

        // Trigger restoration if we have collected all shards
        if currentShardCount == env.ShamirThreshold() </span><span class="cov0" title="0">{
                recovery.RestoreBackingStoreUsingPilotShards(shards)
                // Security: Zero out all shards since we have finished restoration:
                for i := range shards </span><span class="cov0" title="0">{
                        mem.ClearRawBytes(shards[i].Value)
                        shards[i].Id = 0
                }</span>

                // Recover data since we now have the root key in memory:
                <span class="cov0" title="0">recovery.HydrateMemoryFromBackingStore()</span>
        }

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.RestoreResponse{
                RestorationStatus: data.RestorationStatus{
                        ShardsCollected: currentShardCount,
                        ShardsRemaining: env.ShamirThreshold() - currentShardCount,
                        Restored:        currentShardCount == env.ShamirThreshold(),
                },
        }, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "github.com/spiffe/spike/app/nexus/internal/env"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/internal/net"
)

func guardRestoreRequest(
        request reqres.RestoreRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        peerSpiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">if !spiffeid.IsPilotRestore(env.TrustRootForPilot(), peerSpiffeid.String()) </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        // It's unlikely to have 1000 SPIKE Keepers across the board.
        // The indexes start from 1 and increase one-by-one by design.
        <span class="cov0" title="0">const maxShardId = 1000

        if request.Id &lt; 1 || request.Id &gt; maxShardId </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">allZero := true
        for _, b := range request.Shard </span><span class="cov0" title="0">{
                if b != 0 </span><span class="cov0" title="0">{
                        allZero = false
                        break</span>
                }
        }
        <span class="cov0" title="0">if allZero </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.RestoreResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteDeleteSecret handles HTTP DELETE requests for secret deletion
// operations. It validates the JWT token, processes the deletion request,
// and manages the secret deletion workflow.
//
// The function expects a request body containing a path and optional version
// numbers of the secrets to be deleted. If no versions are specified, an empty
// slice is used.
//
// Parameters:
//   - w: http.ResponseWriter for writing the HTTP response
//   - r: *http.Request containing the incoming HTTP request details
//   - audit: *log.AuditEntry for logging audit information about the deletion
//     operation
//
// Returns:
//   - error: Returns nil on successful execution, or an error describing what
//     went wrong
//
// The function performs the following steps:
//  1. Validates the JWT token against the admin token
//  2. Reads and parses the request body
//  3. Processes the secret deletion
//  4. Returns a JSON response
//
// Example request body:
//
//        {
//            "path": "secret/path",
//            "versions": [1, 2, 3]
//        }
//
// Possible errors:
//   - "invalid or missing JWT token": When JWT validation fails
//   - "failed to read request body": When request body cannot be read
//   - "failed to parse request body": When request body is invalid
//   - "failed to marshal response body": When response cannot be serialized
func RouteDeleteSecret(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeDeleteSecret"
        log.AuditRequest(fName, r, audit, log.AuditDelete)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.SecretDeleteRequest, reqres.SecretDeleteResponse](
                requestBody, w,
                reqres.SecretDeleteResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardDeleteSecretRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := request.Path

        versions := request.Versions
        if len(versions) == 0 </span><span class="cov0" title="0">{
                versions = []int{}
        }</span>

        <span class="cov0" title="0">err = state.DeleteSecret(path, versions)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Error(fName, "msg", "Failed to delete secret", "err", err)
        }</span> else<span class="cov0" title="0"> {
                log.Log().Info(fName, "msg", "Secret deleted")
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.SecretDeleteResponse{}, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardDeleteSecretRequest(
        request reqres.SecretDeleteRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        path := request.Path

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePath(path)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretDeleteResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(),
                path,
                []data.PolicyPermission{data.PermissionWrite},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretDeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "errors"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/kv"

        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

func handleGetSecretError(err error, w http.ResponseWriter) error <span class="cov0" title="0">{
        fName := "handleGetSecretError"

        if errors.Is(err, kv.ErrItemNotFound) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Secret not found")

                res := reqres.SecretReadResponse{Err: data.ErrNotFound}
                responseBody := net.MarshalBody(res, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return apiErr.ErrMarshalFailure
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusNotFound, responseBody, w)
                log.Log().Info("routeGetSecret", "msg", "not found")
                return nil</span>
        }

        <span class="cov0" title="0">log.Log().Warn(fName, "msg", "Failed to retrieve secret", "err", err)

        responseBody := net.MarshalBody(reqres.SecretReadResponse{
                Err: data.ErrInternal}, w,
        )
        if responseBody == nil </span><span class="cov0" title="0">{
                return apiErr.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusInternalServerError, responseBody, w)
        log.Log().Error(fName, "msg", data.ErrInternal)
        return err</span>
}

func handleGetSecretMetadataError(err error, w http.ResponseWriter) error <span class="cov0" title="0">{
        fName := "handleGetSecretMetadataError"

        if errors.Is(err, kv.ErrItemNotFound) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Secret not found")

                res := reqres.SecretMetadataResponse{Err: data.ErrNotFound}
                responseBody := net.MarshalBody(res, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return errors.New("failed to marshal response body")
                }</span>

                <span class="cov0" title="0">net.Respond(http.StatusNotFound, responseBody, w)
                return nil</span>
        }

        <span class="cov0" title="0">log.Log().Info(fName, "msg",
                "Failed to retrieve secret", "err", err)
        responseBody := net.MarshalBody(reqres.SecretMetadataResponse{
                Err: "Internal server error"}, w,
        )
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.New("failed to marshal response body")
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusInternalServerError, responseBody, w)
        return err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"

        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteGetSecret handles requests to retrieve a secret at a specific path
// and version.
//
// This endpoint requires a valid admin JWT token for authentication. The
// function retrieves a secret based on the provided path and optional version
// number. If no version is specified, the latest version is returned.
//
// The function follows these steps:
//  1. Validates the JWT token
//  2. Validates and unmarshals the request body
//  3. Attempts to retrieve the secret
//  4. Returns the secret data or an appropriate error response
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for logging audit information
//
// Returns:
//   - error: if an error occurs during request processing.
//
// Request body format:
//
//        {
//            "path": string,     // Path to the secret
//            "version": int      // Optional: specific version to retrieve
//        }
//
// Response format on success (200 OK):
//
//        {
//            "data": {          // The secret data
//                // Secret key-value pairs
//            }
//        }
//
// Error responses:
//   - 401 Unauthorized: Invalid or missing JWT token
//   - 400 Bad Request: Invalid request body
//   - 404 Not Found: Secret doesn't exist at specified path/version
//
// All operations are logged using structured logging.
func RouteGetSecret(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeGetSecret"
        log.AuditRequest(fName, r, audit, log.AuditRead)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return apiErr.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.SecretReadRequest, reqres.SecretReadResponse](
                requestBody, w,
                reqres.SecretReadResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return apiErr.ErrParseFailure
        }</span>

        <span class="cov0" title="0">version := request.Version
        path := request.Path

        err := guardGetSecretRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">secret, err := state.GetSecret(path, version)
        if err == nil </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Secret found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return handleGetSecretError(err, w)
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.SecretReadResponse{
                Secret: data.Secret{Data: secret},
        }, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return apiErr.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info("routeGetSecret", "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardGetSecretRequest(
        request reqres.SecretReadRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        path := request.Path

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePath(path)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretReadResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(),
                path,
                []data.PolicyPermission{data.PermissionRead},
        )

        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretReadResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteListPaths handles requests to retrieve all available secret paths.
//
// This endpoint requires a valid admin JWT token for authentication.
// The function returns a list of all paths where secrets are stored, regardless
// of their version or deletion status.
//
// The function follows these steps:
//  1. Validates the JWT token
//  2. Validates the request body format
//  3. Retrieves all secret paths from the state
//  4. Returns the list of paths
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for logging audit information
//
// Returns:
//   - error: if an error occurs during request processing.
//
// Request body format:
//
//        {} // Empty request body expected
//
// The response format on success (200 OK):
//
//        {
//            "keys": []string   // Array of all secret paths
//        }
//
// Error responses:
//   - 401 Unauthorized: Invalid or missing JWT token
//   - 400 Bad Request: Invalid request body format
//
// All operations are logged using structured logging. This endpoint only
// returns the paths to secrets and not their contents; use RouteGetSecret to
// retrieve actual secret values.
func RouteListPaths(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeListPaths"
        log.AuditRequest(fName, r, audit, log.AuditList)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.SecretListRequest, reqres.SecretListResponse](
                requestBody, w,
                reqres.SecretListResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardListSecretRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">keys := state.ListKeys()
        responseBody := net.MarshalBody(reqres.SecretListResponse{Keys: keys}, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardListSecretRequest(
        _ reqres.SecretListRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), "spike/system/secrets",
                []data.PolicyPermission{data.PermissionList},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/kv"
)

func toSecretMetadataResponse(
        secret *kv.Value,
) reqres.SecretMetadataResponse <span class="cov0" title="0">{
        versions := make(map[int]data.SecretVersionInfo)
        for _, version := range secret.Versions </span><span class="cov0" title="0">{
                versions[version.Version] = data.SecretVersionInfo{
                        CreatedTime: version.CreatedTime,
                        Version:     version.Version,
                        DeletedTime: version.DeletedTime,
                }
        }</span>

        <span class="cov0" title="0">return reqres.SecretMetadataResponse{
                SecretMetadata: data.SecretMetadata{
                        Versions: versions,
                        Metadata: data.SecretMetaDataContent{
                                CurrentVersion: secret.Metadata.CurrentVersion,
                                OldestVersion:  secret.Metadata.OldestVersion,
                                CreatedTime:    secret.Metadata.CreatedTime,
                                UpdatedTime:    secret.Metadata.UpdatedTime,
                                MaxVersions:    secret.Metadata.MaxVersions,
                        },
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "errors"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteGetSecretMetadata handles requests to retrieve a secret metadata at a
// specific path and version.
//
// This endpoint requires a valid admin JWT token for authentication. The
// function retrieves a secret based on the provided path and optional version
// number. If no version is specified, the latest version is returned.
//
// The function follows these steps:
//  1. Validates the JWT token
//  2. Validates and unmarshal the request body
//  3. Attempts to retrieve the secret metadata
//  4. Returns the secret metadata or an appropriate error response
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for logging audit information
//
// Returns:
//   - error: if an error occurs during request processing.
//
// Request body format:
//
//        {
//            "path": string,     // Path to the secret
//            "version": int      // Optional: specific version to retrieve
//        }
//
// Response format on success (200 OK):
//
// "versions": {                       // map[int]SecretMetadataVersionResponse
//
//        "version": {                       // SecretMetadataVersionResponse object
//          "createdTime": "",               // time.Time
//          "version": 0,                    // int
//          "deletedTime": null              // *time.Time (pointer, can be null)
//         }
//        },
//
// "metadata": {                        // SecretRawMetadataResponse object
//
//         "currentVersion": 0,               // int
//         "oldestVersion": 0,                // int
//         "createdTime": "",                 // time.Time
//         "updatedTime": "",                 // time.Time
//         "maxVersions": 0                   // int
//        },
//
// "err": null                          // ErrorCode
//
// Error responses:
//   - 401 Unauthorized: Invalid or missing JWT token
//   - 400 Bad Request: Invalid request body
//   - 404 Not Found: Secret doesn't exist at specified path/version
//
// All operations are logged using structured logging.
func RouteGetSecretMetadata(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeGetSecretMetadata"

        log.Log().Info(fName,
                "method", r.Method,
                "path", r.URL.Path,
                "query", r.URL.RawQuery,
        )
        audit.Action = log.AuditRead

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.New("failed to read request body")
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.SecretMetadataRequest, reqres.SecretMetadataResponse](
                requestBody, w,
                reqres.SecretMetadataResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.New("failed to parse request body")
        }</span>

        <span class="cov0" title="0">err := guardGetSecretMetadataRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := request.Path
        version := request.Version

        rawSecret, err := state.GetRawSecret(path, version)
        if err != nil </span><span class="cov0" title="0">{
                return handleGetSecretMetadataError(err, w)
        }</span>

        <span class="cov0" title="0">response := toSecretMetadataResponse(rawSecret)
        responseBody := net.MarshalBody(response, w)

        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.New("failed to marshal response body")
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info("routeGetSecret", "msg", "OK")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardGetSecretMetadataRequest(
        request reqres.SecretMetadataRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        path := request.Path

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretMetadataResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretMetadataResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePath(path)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretMetadataResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), path,
                []data.PolicyPermission{data.PermissionRead},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretListResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RoutePutSecret handles HTTP requests to create or update secrets at a
// specified path.
//
// This endpoint requires a valid admin JWT token for authentication. It accepts
// a PUT request with a JSON body containing the secret path and values to
// store. The function performs an upsert operation, creating a new secret if it
// doesn't exist or updating an existing one.
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for logging audit information
//
// Returns:
//   - error: if an error occurs during request processing.
//
// Request body format:
//
//        {
//            "path": string,          // Path where the secret should be stored
//            "values": map[string]any // Key-value pairs representing the secret data
//        }
//
// Responses:
//   - 200 OK: Secret successfully created or updated
//   - 400 Bad Request: Invalid request body or parameters
//   - 401 Unauthorized: Invalid or missing JWT token
//
// The function logs its progress at various stages using structured logging.
func RoutePutSecret(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routePutSecret"
        log.AuditRequest(fName, r, audit, log.AuditCreate)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">request := net.HandleRequest[
                reqres.SecretPutRequest, reqres.SecretPutResponse](
                requestBody, w,
                reqres.SecretPutResponse{Err: data.ErrBadInput},
        )
        if request == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardPutSecretMetadataRequest(*request, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">values := request.Values
        path := request.Path

        state.UpsertSecret(path, values)
        log.Log().Info(fName, "msg", "Secret upserted")

        responseBody := net.MarshalBody(reqres.SecretPutResponse{}, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        apiErr "github.com/spiffe/spike-sdk-go/api/errors"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/net"
)

func guardPutSecretMetadataRequest(
        request reqres.SecretPutRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        values := request.Values
        path := request.Path

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretPutResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>
        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretPutResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePath(path)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretPutResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return apiErr.ErrInvalidInput
        }</span>

        <span class="cov0" title="0">for k := range values </span><span class="cov0" title="0">{
                err := validation.ValidateName(k)
                if err != nil </span><span class="cov0" title="0">{
                        responseBody := net.MarshalBody(reqres.SecretPutResponse{
                                Err: data.ErrBadInput,
                        }, w)
                        net.Respond(http.StatusUnauthorized, responseBody, w)
                        return apiErr.ErrInvalidInput
                }</span>
        }

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(), path,
                []data.PolicyPermission{data.PermissionWrite},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretPutResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return apiErr.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/api/errors"

        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "github.com/spiffe/spike/internal/log"
        "github.com/spiffe/spike/internal/net"
)

// RouteUndeleteSecret handles HTTP requests to restore previously deleted
// secrets.
//
// This endpoint requires a valid admin JWT token for authentication. It accepts
// a POST request with a JSON body containing a path to the secret and
// optionally specific versions to undelete. If no versions are specified,
// an empty version list is used.
//
// The function validates the JWT, reads and unmarshals the request body,
// processes the undelete operation, and returns a "200 OK" response upon success.
//
// Parameters:
//   - w: http.ResponseWriter to write the HTTP response
//   - r: *http.Request containing the incoming HTTP request
//   - audit: *log.AuditEntry for logging audit information
//
// Returns:
//   - error: if an error occurs during request processing.
//
// Request body format:
//
//        {
//            "path": string,   // Path to the secret to undelete
//            "versions": []int // Optional list of specific versions to undelete
//        }
//
// Responses:
//   - 200 OK: Secret successfully undeleted
//   - 400 Bad Request: Invalid request body or parameters
//   - 401 Unauthorized: Invalid or missing JWT token
//
// The function logs its progress at various stages using structured logging.
func RouteUndeleteSecret(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        const fName = "routeUndeleteSecret"
        log.AuditRequest(fName, r, audit, log.AuditUndelete)

        requestBody := net.ReadRequestBody(w, r)
        if requestBody == nil </span><span class="cov0" title="0">{
                return errors.ErrReadFailure
        }</span>

        <span class="cov0" title="0">req := net.HandleRequest[
                reqres.SecretUndeleteRequest, reqres.SecretUndeleteResponse](
                requestBody, w,
                reqres.SecretUndeleteResponse{Err: data.ErrBadInput},
        )
        if req == nil </span><span class="cov0" title="0">{
                return errors.ErrParseFailure
        }</span>

        <span class="cov0" title="0">err := guardSecretUndeleteRequest(*req, w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := req.Path
        versions := req.Versions
        if len(versions) == 0 </span><span class="cov0" title="0">{
                versions = []int{}
        }</span>

        <span class="cov0" title="0">err = state.UndeleteSecret(path, versions)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Error(fName, "msg", "Failed to undelete secret", "err", err)
        }</span> else<span class="cov0" title="0"> {
                log.Log().Info(fName, "msg", "Secret undeleted")
        }</span>

        <span class="cov0" title="0">responseBody := net.MarshalBody(reqres.SecretUndeleteResponse{}, w)
        if responseBody == nil </span><span class="cov0" title="0">{
                return errors.ErrMarshalFailure
        }</span>

        <span class="cov0" title="0">net.Respond(http.StatusOK, responseBody, w)
        log.Log().Info(fName, "msg", data.ErrSuccess)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "github.com/spiffe/spike-sdk-go/api/errors"
        state "github.com/spiffe/spike/app/nexus/internal/state/base"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"
        "github.com/spiffe/spike-sdk-go/spiffe"
        "github.com/spiffe/spike-sdk-go/validation"

        "github.com/spiffe/spike/internal/net"
)

func guardSecretUndeleteRequest(
        request reqres.SecretUndeleteRequest, w http.ResponseWriter, r *http.Request,
) error <span class="cov0" title="0">{
        path := request.Path

        spiffeid, err := spiffe.IdFromRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretUndeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return err
        }</span>
        <span class="cov0" title="0">err = validation.ValidateSpiffeId(spiffeid.String())
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretUndeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
        }</span>

        <span class="cov0" title="0">err = validation.ValidatePath(path)
        if err != nil </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretUndeleteResponse{
                        Err: data.ErrBadInput,
                }, w)
                net.Respond(http.StatusBadRequest, responseBody, w)
                return err
        }</span>

        <span class="cov0" title="0">allowed := state.CheckAccess(
                spiffeid.String(),
                path,
                []data.PolicyPermission{data.PermissionWrite},
        )
        if !allowed </span><span class="cov0" title="0">{
                responseBody := net.MarshalBody(reqres.SecretUndeleteResponse{
                        Err: data.ErrUnauthorized,
                }, w)
                net.Respond(http.StatusUnauthorized, responseBody, w)
                return errors.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package memory implements an in-memory storage backend for managing
// secrets and policies in the SPIKE system. This package includes a
// no-op implementation, `NoopStore`, which acts as a placeholder or
// testing tool for scenarios where persistent storage isn't required.
//
// The `NoopStore` provides implementations for interfaces related to
// storing and retrieving secrets and policies but does not perform
// any actual storage operations. All methods in `NoopStore` are no-ops and
// always return `nil` or equivalent default values.
package memory

import (
        "context"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/kv"
)

// NoopStore provides a no-op implementation of a storage backend.
// This implementation can be used for testing or as a placeholder
// where no actual storage is needed. NoopStore is also used when the
// backing kv is configured to be in-memory.
type NoopStore struct {
}

// Close implements the closing operation for the kv.
// This implementation is a no-op and always returns nil.
func (s *NoopStore) Close(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Initialize prepares the kv for use.
// This implementation is a no-op and always returns nil.
func (s *NoopStore) Initialize(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// LoadSecret retrieves a secret from the kv by its path.
// This implementation always returns nil secret and nil error.
func (s *NoopStore) LoadSecret(
        _ context.Context, _ string,
) (*kv.Value, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// LoadAllSecrets retrieves all secrets stored in the kv.
// This implementation always returns nil and nil error.
func (s *NoopStore) LoadAllSecrets(_ context.Context) (
        map[string]*kv.Value, error,
) <span class="cov0" title="0">{
        return nil, nil
}</span>

// StoreSecret saves a secret to the kv at the specified path.
// This implementation is a no-op and always returns nil.
func (s *NoopStore) StoreSecret(
        _ context.Context, _ string, _ kv.Value,
) error <span class="cov0" title="0">{
        return nil
}</span>

// StorePolicy stores a policy in the no-op kv.
// This implementation is a no-op and always returns nil.
func (s *NoopStore) StorePolicy(_ context.Context, _ data.Policy) error <span class="cov0" title="0">{
        return nil
}</span>

// LoadPolicy retrieves a policy from the kv by its ID.
// This implementation always returns nil and nil error.
func (s *NoopStore) LoadPolicy(
        _ context.Context, _ string,
) (*data.Policy, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// LoadAllPolicies retrieves all policies from the no-op store.
// This implementation always returns nil and nil error.
func (s *NoopStore) LoadAllPolicies(
        _ context.Context,
) (map[string]*data.Policy, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// DeletePolicy removes a policy from the no-op kv by its ID.
// This implementation is a no-op and always returns nil.
func (s *NoopStore) DeletePolicy(_ context.Context, _ string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package sqlite

import (
        "crypto/aes"
        "crypto/cipher"
        "encoding/hex"
        "fmt"

        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/persist"

        "github.com/spiffe/spike/app/nexus/internal/state/backend"
)

// New creates a new DataStore instance with the provided configuration.
// It validates the encryption key and initializes the AES-GCM cipher.
//
// The encryption key must be 16, 24, or 32 bytes in length (for AES-128,
// AES-192, or AES-256 respectively).
//
// Returns an error if:
// - The options are invalid
// - The encryption key is malformed or has an invalid length
// - The cipher initialization fails
func New(cfg backend.Config) (backend.Backend, error) <span class="cov0" title="0">{
        opts, err := persist.ParseOptions(cfg.Options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sqlite options: %w", err)
        }</span>

        <span class="cov0" title="0">key, err := hex.DecodeString(cfg.EncryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid encryption key: %w", err)
        }</span>

        // Validate key length
        <span class="cov0" title="0">if len(key) != 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "invalid encryption key length: must be 32 bytes",
                )
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;persist.DataStore{
                Cipher: gcm,
                Opts:   opts,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "crypto/rand"
        "fmt"
        "io"
)

func (s *DataStore) encrypt(data []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        nonce := make([]byte, s.Cipher.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>
        <span class="cov0" title="0">ciphertext := s.Cipher.Seal(nil, nonce, data, nil)
        return ciphertext, nonce, nil</span>
}

func (s *DataStore) decrypt(ciphertext, nonce []byte) ([]byte, error) <span class="cov0" title="0">{
        plaintext, err := s.Cipher.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "path/filepath"

        "github.com/spiffe/spike/app/nexus/internal/env"
)

// Initialize prepares the DataStore for use by:
// - Creating the necessary data directory
// - Opening the SQLite database connection
// - Configuring connection pool settings
// - Creating required database tables
//
// It returns an error if:
// - The backend is already initialized
// - The data directory creation fails
// - The database connection fails
// - Table creation fails
//
// This method is thread-safe.
func (s *DataStore) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.db != nil </span><span class="cov0" title="0">{
                return errors.New("backend already initialized")
        }</span>

        <span class="cov0" title="0">if err := s.createDataDir(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data directory: %w", err)
        }</span>

        <span class="cov0" title="0">dbPath := filepath.Join(s.Opts.DataDir, s.Opts.DatabaseFile)

        // We don't need a username/password for SQLite.
        // Access to SQLite is controlled by regular filesystem permissions.
        db, err := sql.Open(
                "sqlite3",
                fmt.Sprintf("%s?_journal_mode=%s&amp;_busy_timeout=%d",
                        dbPath,
                        s.Opts.JournalMode,
                        s.Opts.BusyTimeoutMs))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(s.Opts.MaxOpenConns)
        db.SetMaxIdleConns(s.Opts.MaxIdleConns)
        db.SetConnMaxLifetime(s.Opts.ConnMaxLifetime)

        // Use the existing database if the schema is not to be created.
        if env.DatabaseSkipSchemaCreation() </span><span class="cov0" title="0">{
                s.db = db
                return nil
        }</span>

        // Create tables
        <span class="cov0" title="0">if err := s.createTables(ctx, db); err != nil </span><span class="cov0" title="0">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create tables: %w", err)</span>
        }

        <span class="cov0" title="0">s.db = db
        return nil</span>
}

// Close safely closes the database connection.
// It ensures the database is closed only once even if called multiple times.
//
// Returns any error encountered while closing the database connection.
func (s *DataStore) Close(_ context.Context) error <span class="cov0" title="0">{
        var err error
        s.closeOnce.Do(func() </span><span class="cov0" title="0">{
                err = s.db.Close()
        }</span>)
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "github.com/spiffe/spike/app/nexus/internal/env"
        "time"
)

// Options defines SQLite-specific configuration options
type Options struct {
        // DataDir specifies the directory where the SQLite database file
        // will be stored
        DataDir string

        // DatabaseFile specifies the name of the SQLite database file
        DatabaseFile string

        // JournalMode specifies the SQLite journal mode
        // (DELETE, WAL, MEMORY, etc.)
        JournalMode string

        // BusyTimeoutMs specifies the busy timeout in milliseconds
        BusyTimeoutMs int

        // MaxOpenConns specifies the maximum number of open connections
        MaxOpenConns int

        // MaxIdleConns specifies the maximum number of idle connections
        MaxIdleConns int

        // ConnMaxLifetime specifies the maximum amount of time
        // a connection may be reused
        ConnMaxLifetime time.Duration
}

// DefaultOptions returns the default SQLite options
func DefaultOptions() *Options <span class="cov0" title="0">{
        return &amp;Options{
                DataDir:         ".data",
                DatabaseFile:    "spike.db",
                JournalMode:     env.DatabaseJournalMode(),
                BusyTimeoutMs:   env.DatabaseBusyTimeoutMs(),
                MaxOpenConns:    env.DatabaseMaxOpenConns(),
                MaxIdleConns:    env.DatabaseMaxIdleConns(),
                ConnMaxLifetime: env.DatabaseConnMaxLifetimeSec(),
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "fmt"
        "time"

        "github.com/spiffe/spike/app/nexus/internal/state/backend"
)

// ParseOptions parses and validates the provided backend options
func ParseOptions(opts map[backend.DatabaseConfigKey]any) (*Options, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                return DefaultOptions(), nil
        }</span>

        <span class="cov0" title="0">sqliteOpts := &amp;Options{}

        // Parse each field from the map
        if dataDir, ok := opts[backend.KeyDataDir].(string); ok </span><span class="cov0" title="0">{
                sqliteOpts.DataDir = dataDir
        }</span>
        <span class="cov0" title="0">if dbFile, ok := opts[backend.KeyDatabaseFile].(string); ok </span><span class="cov0" title="0">{
                sqliteOpts.DatabaseFile = dbFile
        }</span>
        <span class="cov0" title="0">if journalMode, ok := opts[backend.KeyJournalMode].(string); ok </span><span class="cov0" title="0">{
                sqliteOpts.JournalMode = journalMode
        }</span>
        <span class="cov0" title="0">if busyTimeout, ok := opts[backend.KeyBusyTimeoutMs].(int); ok </span><span class="cov0" title="0">{
                sqliteOpts.BusyTimeoutMs = busyTimeout
        }</span>
        <span class="cov0" title="0">if maxOpen, ok := opts[backend.KeyMaxOpenConns].(int); ok </span><span class="cov0" title="0">{
                sqliteOpts.MaxOpenConns = maxOpen
        }</span>
        <span class="cov0" title="0">if maxIdle, ok := opts[backend.KeyMaxIdleConns].(int); ok </span><span class="cov0" title="0">{
                sqliteOpts.MaxIdleConns = maxIdle
        }</span>
        <span class="cov0" title="0">if lifetime, ok := opts[backend.KeyConnMaxLifetimeSeconds].(time.Duration); ok </span><span class="cov0" title="0">{
                sqliteOpts.ConnMaxLifetime = lifetime
        }</span>

        // Apply defaults for zero values
        <span class="cov0" title="0">if sqliteOpts.DataDir == "" </span><span class="cov0" title="0">{
                sqliteOpts.DataDir = DefaultOptions().DataDir
        }</span>
        <span class="cov0" title="0">if sqliteOpts.DatabaseFile == "" </span><span class="cov0" title="0">{
                sqliteOpts.DatabaseFile = DefaultOptions().DatabaseFile
        }</span>
        <span class="cov0" title="0">if sqliteOpts.JournalMode == "" </span><span class="cov0" title="0">{
                sqliteOpts.JournalMode = DefaultOptions().JournalMode
        }</span>
        <span class="cov0" title="0">if sqliteOpts.BusyTimeoutMs == 0 </span><span class="cov0" title="0">{
                sqliteOpts.BusyTimeoutMs = DefaultOptions().BusyTimeoutMs
        }</span>
        <span class="cov0" title="0">if sqliteOpts.MaxOpenConns == 0 </span><span class="cov0" title="0">{
                sqliteOpts.MaxOpenConns = DefaultOptions().MaxOpenConns
        }</span>
        <span class="cov0" title="0">if sqliteOpts.MaxIdleConns == 0 </span><span class="cov0" title="0">{
                sqliteOpts.MaxIdleConns = DefaultOptions().MaxIdleConns
        }</span>
        <span class="cov0" title="0">if sqliteOpts.ConnMaxLifetime == 0 </span><span class="cov0" title="0">{
                sqliteOpts.ConnMaxLifetime = DefaultOptions().ConnMaxLifetime
        }</span>

        // Validate options
        <span class="cov0" title="0">if sqliteOpts.MaxIdleConns &gt; sqliteOpts.MaxOpenConns </span><span class="cov0" title="0">{
                return nil,
                        fmt.Errorf(
                                "MaxIdleConns (%d) cannot be greater than MaxOpenConns (%d)",
                                sqliteOpts.MaxIdleConns, sqliteOpts.MaxOpenConns)
        }</span>

        <span class="cov0" title="0">return sqliteOpts, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "regexp"

        "github.com/spiffe/spike-sdk-go/api/entity/data"

        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/ddl"
)

// DeletePolicy removes a policy from the database by its ID.
//
// Uses serializable transaction isolation to ensure consistency.
// Automatically rolls back on error.
//
// Parameters:
//   - ctx: Context for the database operation
//   - id: Unique identifier of the policy to delete
//
// Returns error if:
//   - Transaction operations fail
//   - Policy deletion fails
func (s *DataStore) DeletePolicy(ctx context.Context, id string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed := false
        defer func(tx *sql.Tx) </span><span class="cov0" title="0">{
                if !committed </span><span class="cov0" title="0">{
                        err := tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("failed to rollback transaction: %v\n", err)
                        }</span>
                }
        }(tx)

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, ddl.QueryDeletePolicy, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete policy: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed = true
        return nil</span>
}

// StorePolicy saves or updates a policy in the database.
//
// Uses serializable transaction isolation to ensure consistency.
// Automatically rolls back on error.
//
// Parameters:
//   - ctx: Context for the database operation
//   - policy: Policy data to store, containing ID, name, patterns, and creation
//     time
//
// Returns error if:
//   - Transaction operations fail
//   - Policy storage fails
func (s *DataStore) StorePolicy(ctx context.Context, policy data.Policy) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed := false
        defer func(tx *sql.Tx) </span><span class="cov0" title="0">{
                if !committed </span><span class="cov0" title="0">{
                        err := tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("failed to rollback transaction: %v\n", err)
                        }</span>
                }
        }(tx)

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, ddl.QueryUpsertPolicy,
                policy.Id,
                policy.Name,
                policy.SpiffeIdPattern,
                policy.PathPattern,
                policy.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store policy: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed = true
        return nil</span>
}

// LoadPolicy retrieves a policy from the database and compiles its patterns.
//
// The function loads policy data and compiles regex patterns for SPIFFE ID
// and path matching if they aren't wildcards (*).
//
// Parameters:
//   - ctx: Context for the database operation
//   - id: Unique identifier of the policy to load
//
// Returns:
//   - *data.Policy: Loaded policy with compiled patterns, nil if not found
//   - error: Database errors or pattern compilation errors
func (s *DataStore) LoadPolicy(
        ctx context.Context, id string,
) (*data.Policy, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var policy data.Policy
        policy.Id = id // Set the ID since we queried with it

        err := s.db.QueryRowContext(ctx, ddl.QueryLoadPolicy, id).Scan(
                &amp;policy.Name,
                &amp;policy.SpiffeIdPattern,
                &amp;policy.PathPattern,
                &amp;policy.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load policy: %w", err)</span>
        }

        // Compile the patterns just like in CreatePolicy
        <span class="cov0" title="0">if policy.SpiffeIdPattern != "*" </span><span class="cov0" title="0">{
                idRegex, err := regexp.Compile(policy.SpiffeIdPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid spiffeid pattern: %w", err)
                }</span>
                <span class="cov0" title="0">policy.IdRegex = idRegex</span>
        }

        <span class="cov0" title="0">if policy.PathPattern != "*" </span><span class="cov0" title="0">{
                pathRegex, err := regexp.Compile(policy.PathPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid path pattern: %w", err)
                }</span>
                <span class="cov0" title="0">policy.PathRegex = pathRegex</span>
        }

        <span class="cov0" title="0">return &amp;policy, nil</span>
}

// LoadAllPolicies retrieves all policies from the backend storage.
//
// The function loads all policy data and compiles regex patterns for SPIFFE ID
// and path matching if they aren't wildcards (*).
//
// Parameters:
//   - ctx: Context for the database operation
//
// Returns:
//   - map[string]*data.Policy: Map of policy IDs to loaded policies with compiled patterns
//   - error: Database errors or pattern compilation errors
func (s *DataStore) LoadAllPolicies(ctx context.Context) (map[string]*data.Policy, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Query to get all policies
        rows, err := s.db.QueryContext(ctx, ddl.QueryAllPolicies)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query policies: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("failed to close rows: %v\n", err)
                }</span>
        }(rows)

        // Map to store all policies
        <span class="cov0" title="0">policies := make(map[string]*data.Policy)

        // Iterate over policy rows
        for rows.Next() </span><span class="cov0" title="0">{
                var policy data.Policy

                if err := rows.Scan(
                        &amp;policy.Id,
                        &amp;policy.Name,
                        &amp;policy.SpiffeIdPattern,
                        &amp;policy.PathPattern,
                        &amp;policy.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan policy: %w", err)
                }</span>

                // Compile the patterns just like in LoadPolicy
                <span class="cov0" title="0">if policy.SpiffeIdPattern != "*" </span><span class="cov0" title="0">{
                        idRegex, err := regexp.Compile(policy.SpiffeIdPattern)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid spiffeid pattern for policy %s: %w", policy.Id, err)
                        }</span>
                        <span class="cov0" title="0">policy.IdRegex = idRegex</span>
                }

                <span class="cov0" title="0">if policy.PathPattern != "*" </span><span class="cov0" title="0">{
                        pathRegex, err := regexp.Compile(policy.PathPattern)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid path pattern for policy %s: %w", policy.Id, err)
                        }</span>
                        <span class="cov0" title="0">policy.PathRegex = pathRegex</span>
                }

                <span class="cov0" title="0">policies[policy.Id] = &amp;policy</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate policy rows: %w", err)
        }</span>

        <span class="cov0" title="0">return policies, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "database/sql"
        "os"

        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/ddl"
)

func (s *DataStore) createDataDir() error <span class="cov0" title="0">{
        return os.MkdirAll(s.Opts.DataDir, 0750)
}</span>

func (s *DataStore) createTables(ctx context.Context, db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.ExecContext(ctx, ddl.QueryInitialize)
        return err
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"

        "github.com/spiffe/spike-sdk-go/kv"

        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/ddl"
)

// StoreSecret stores a secret at the specified path with its metadata and
// versions. It performs the following operations atomically within a
// transaction:
//   - Updates the secret metadata (current version, creation time, update time)
//   - Stores all secret versions with their respective data encrypted using
//     AES-GCM
//
// The secret data is JSON-encoded before encryption.
//
// Returns an error if:
// - The transaction fails to begin or commit
// - Data marshaling fails
// - Encryption fails
// - Database operations fail
//
// This method is thread-safe.
func (s *DataStore) StoreSecret(
        ctx context.Context, path string, secret kv.Value,
) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed := false

        defer func(tx *sql.Tx) </span><span class="cov0" title="0">{
                if !committed </span><span class="cov0" title="0">{
                        err := tx.Rollback()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("failed to rollback transaction: %v\n", err)
                        }</span>
                }
        }(tx)

        // Update metadata
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, ddl.QueryUpdateSecretMetadata,
                path, secret.Metadata.CurrentVersion,
                secret.Metadata.CreatedTime, secret.Metadata.UpdatedTime)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to kv secret metadata: %w", err)
        }</span>

        // Update versions
        <span class="cov0" title="0">for version, sv := range secret.Versions </span><span class="cov0" title="0">{
                data, err := json.Marshal(sv.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal secret values: %w", err)
                }</span>

                <span class="cov0" title="0">encrypted, nonce, err := s.encrypt(data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt secret data: %w", err)
                }</span>

                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, ddl.QueryUpsertSecret,
                        path, version, nonce, encrypted, sv.CreatedTime, sv.DeletedTime)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to kv secret version: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">committed = true

        return nil</span>
}

// LoadSecret retrieves a secret and all its versions from the specified path.
// It performs the following operations:
// - Loads the secret metadata
// - Retrieves all secret versions
// - Decrypts and unmarshals the version data
//
// Returns:
//   - (nil, nil) if the secret doesn't exist
//   - (nil, error) if any operation fails
//   - (*kv.Secret, nil) with the decrypted secret and all its versions on
//     success
//
// This method is thread-safe.
func (s *DataStore) LoadSecret(
        ctx context.Context, path string,
) (*kv.Value, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return s.loadSecretInternal(ctx, path)
}</span>

// LoadAllSecrets retrieves all secrets from the database.
// It returns a map where the keys are secret paths and the values are the
// corresponding secrets.
// Each secret includes its metadata and all versions with decrypted data.
// If an error occurs during the retrieval process, it returns nil and the
// error. This method acquires a read lock to ensure consistent access to the
// database.
//
// Contexts that are canceled or reach their deadline will result in the
// operation being interrupted early and returning an error.
//
// Example usage:
//
//        secrets, err := dataStore.LoadAllSecrets(context.Background())
//        if err != nil {
//            log.Fatalf("Failed to load secrets: %v", err)
//        }
//        for path, secret := range secrets {
//            fmt.Printf("Secret at path %s has %d versions\n", path,
//              len(secret.Versions))
//        }
func (s *DataStore) LoadAllSecrets(
        ctx context.Context,
) (map[string]*kv.Value, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Get all secret paths
        rows, err := s.db.QueryContext(ctx, ddl.QueryPathsFromMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query secret paths: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("failed to close rows: %v\n", err)
                }</span>
        }(rows)

        // Map to store all secrets
        <span class="cov0" title="0">secrets := make(map[string]*kv.Value)

        // Iterate over paths
        for rows.Next() </span><span class="cov0" title="0">{
                var path string
                if err := rows.Scan(&amp;path); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan path: %w", err)
                }</span>

                // Load the full secret for this path
                <span class="cov0" title="0">secret, err := s.loadSecretInternal(ctx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load secret at path %s: %w", path, err)
                }</span>

                <span class="cov0" title="0">if secret != nil </span><span class="cov0" title="0">{
                        secrets[path] = secret
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate secret paths: %w", err)
        }</span>

        <span class="cov0" title="0">return secrets, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/spiffe/spike-sdk-go/kv"
        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite/ddl"
)

func (s *DataStore) loadSecretInternal(
        ctx context.Context, path string,
) (*kv.Value, error) <span class="cov0" title="0">{
        var secret kv.Value

        // Load metadata
        err := s.db.QueryRowContext(ctx, ddl.QuerySecretMetadata, path).Scan(
                &amp;secret.Metadata.CurrentVersion,
                &amp;secret.Metadata.CreatedTime,
                &amp;secret.Metadata.UpdatedTime)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to load secret metadata: %w", err)</span>
        }

        // Load versions
        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, ddl.QuerySecretVersions, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query secret versions: %w", err)
        }</span>
        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("failed to close rows: %v\n", err)
                }</span>
        }(rows)

        <span class="cov0" title="0">secret.Versions = make(map[int]kv.Version)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        version     int
                        nonce       []byte
                        encrypted   []byte
                        createdTime time.Time
                        deletedTime sql.NullTime
                )

                if err := rows.Scan(
                        &amp;version, &amp;nonce,
                        &amp;encrypted, &amp;createdTime, &amp;deletedTime,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan secret version: %w", err)
                }</span>

                <span class="cov0" title="0">decrypted, err := s.decrypt(encrypted, nonce)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decrypt secret version: %w", err)
                }</span>

                <span class="cov0" title="0">var values map[string]string
                if err := json.Unmarshal(decrypted, &amp;values); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal secret values: %w", err)
                }</span>

                <span class="cov0" title="0">sv := kv.Version{
                        Data:        values,
                        CreatedTime: createdTime,
                }
                if deletedTime.Valid </span><span class="cov0" title="0">{
                        sv.DeletedTime = &amp;deletedTime.Time
                }</span>

                <span class="cov0" title="0">secret.Versions[version] = sv</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate secret versions: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;secret, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

import (
        "sync"

        "github.com/spiffe/spike-sdk-go/kv"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/internal/log"
)

// Global variables for storing secrets and policies with thread-safety.
var (
        // secretStore is a key-value store for managing secrets with version control.
        secretStore = kv.New(kv.Config{
                MaxSecretVersions: env.MaxSecretVersions(),
        })
        // secretStoreMu provides mutual exclusion for access to the secret store.
        secretStoreMu sync.RWMutex
)

// policies is a thread-safe map used to store policy information.
var policies sync.Map

// Global variables related to the root key with thread-safety protection.
var (
        // rootKey is a 32-byte array that stores the cryptographic root key.
        // It is initialized to zeroes by default.
        rootKey [32]byte
        // rootKeyMu provides mutual exclusion for access to the root key.
        rootKeyMu sync.RWMutex
)

// RootKeyNoLock returns a copy of the root key without acquiring the lock.
// This should only be used in contexts where the lock is already held
// or thread safety is managed externally.
//
// Returns:
//   - *[32]byte: Pointer to the root key
func RootKeyNoLock() *[32]byte <span class="cov0" title="0">{
        return &amp;rootKey
}</span>

// LockRootKey acquires an exclusive lock on the root key.
// This must be paired with a corresponding call to UnlockRootKey.
func LockRootKey() <span class="cov0" title="0">{
        rootKeyMu.Lock()
}</span>

// UnlockRootKey releases an exclusive lock on the root key previously
// acquired with LockRootKey.
func UnlockRootKey() <span class="cov0" title="0">{
        rootKeyMu.Unlock()
}</span>

// RootKeyZero checks if the root key contains only zero bytes.
//
// If the rot key is zero and SPIKE Nexus is not in "in memory" mode,
// then it means SPIKE Nexus has not been initialized yet, and any secret
// and policy management operation should be denied at the API level.
//
// Returns:
//   - bool: true if the root key contains only zeroes, false otherwise
func RootKeyZero() bool <span class="cov0" title="0">{
        rootKeyMu.RLock()
        defer rootKeyMu.RUnlock()

        for _, b := range rootKey[:] </span><span class="cov0" title="0">{
                if b != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// SetRootKey updates the root key with the provided value.
// This function does not own its parameter; the `rk` argument can
// be (and should be) cleaned up after calling this function without
// impacting the saved root key.
//
// Parameters:
//   - rk: Pointer to a 32-byte array containing the new root key value
func SetRootKey(rk *[32]byte) <span class="cov0" title="0">{
        fName := "SetRootKey"
        log.Log().Info(fName, "msg", "Setting root key")

        rootKeyMu.Lock()
        defer rootKeyMu.Unlock()

        for i := range rootKey </span><span class="cov0" title="0">{
                rootKey[i] = rk[i]
        }</span>

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Root key set")</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

import (
        "github.com/spiffe/spike/app/nexus/internal/state/persist"
)

// Initialize initializes the backend storage with the provided root key.
func Initialize(r *[32]byte) <span class="cov0" title="0">{
        // No need for a lock:
        // This method is called only once during initial bootstrapping.
        persist.InitializeBackend(r)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

// ListKeys returns a slice of strings containing all keys currently stored
// in the key-value store. The function acquires a lock on the store to ensure
// a consistent view of the keys during enumeration.
//
// The returned slice contains the paths to all keys, regardless of their
// version status (active or deleted). The paths are returned in lexicographical
// order.
//
// Returns:
//   - []string: A slice containing all key paths in the store
//
// Example:
//
//        keys := ListKeys()
//        for _, key := range keys {
//            fmt.Printf("Found key: %s\n", key)
//        }
func ListKeys() []string <span class="cov0" title="0">{
        secretStoreMu.Lock()
        defer secretStoreMu.Unlock()
        return secretStore.List()
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

import (
        "errors"
        "fmt"
        "github.com/spiffe/spike/app/nexus/internal/env"
        "regexp"
        "time"

        "github.com/google/uuid"
        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/nexus/internal/state/persist"
)

var (
        ErrPolicyNotFound = errors.New("policy not found")
        ErrPolicyExists   = errors.New("policy already exists")
        ErrInvalidPolicy  = errors.New("invalid policy")
)

// CheckAccess determines if a given SPIFFE ID has the required permissions for
// a specific path. It first checks if the ID belongs to SPIKE Pilot (which has
// unrestricted access), then evaluates against all defined policies. Policies
// are checked in order, with wildcard patterns evaluated first, followed by
// specific pattern matching using regular expressions.
//
// Parameters:
//   - spiffeId: The SPIFFE ID of the requestor
//   - path: The resource path being accessed
//   - wants: Slice of permissions being requested
//
// Returns:
//   - bool: true if access is granted, false otherwise
//
// The function grants access if any of these conditions are met:
//  1. The requestor is a SPIKE Pilot instance.
//  2. A matching policy has the super permission
//  3. A matching policy contains all requested permissions
//
// A policy matches when:
//  1. It has wildcard patterns ("*") for both SPIFFE ID and path, or
//  2. Its SPIFFE ID pattern matches the requestor's ID, and its path pattern
//     matches the requested path
func CheckAccess(
        peerSpiffeId string, path string, wants []data.PolicyPermission,
) bool <span class="cov0" title="0">{
        // Role:SpikePilot can always manage secrets and policies.
        if spiffeid.IsPilot(env.TrustRootForPilot(), peerSpiffeId) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">policies := ListPolicies()
        for _, policy := range policies </span><span class="cov0" title="0">{
                // Check the wildcard pattern first
                if policy.SpiffeIdPattern == "*" &amp;&amp; policy.PathPattern == "*" </span><span class="cov0" title="0">{
                        if hasAllPermissions(policy.Permissions, wants) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check specific patterns using pre-compiled regexes

                <span class="cov0" title="0">if policy.SpiffeIdPattern != "*" </span><span class="cov0" title="0">{
                        if !policy.IdRegex.MatchString(peerSpiffeId) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if policy.PathPattern != "*" </span><span class="cov0" title="0">{
                        if !policy.PathRegex.MatchString(path) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if contains(policy.Permissions, data.PermissionSuper) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if hasAllPermissions(policy.Permissions, wants) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// CreatePolicy creates a new policy in the system after validating and
// preparing it. The function compiles regex patterns, generates a UUID, and
// sets the creation timestamp before storing the policy.
//
// Parameters:
//   - policy: The policy to create. Must have a non-empty Name field.
//     SpiffeIdPattern and PathPattern can be "*" for wildcard matching
//     or valid regular expressions.
//
// Returns:
//   - data.Policy: The created policy, including generated ID and timestamps
//   - error: ErrInvalidPolicy if policy name is empty, or regex compilation
//     errors for invalid patterns
//
// The function performs the following modifications to the input policy:
//   - Compiles and stores regex patterns for non-wildcard SpiffeIdPattern
//     and PathPattern
//   - Generates and sets a new UUID as the policy ID
//   - Sets CreatedAt to current time if not already set
func CreatePolicy(policy data.Policy) (data.Policy, error) <span class="cov0" title="0">{
        if policy.Name == "" </span><span class="cov0" title="0">{
                return data.Policy{}, ErrInvalidPolicy
        }</span>

        <span class="cov0" title="0">var err error

        // Check for duplicate policy name
        policies.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                if value.(data.Policy).Name == policy.Name </span><span class="cov0" title="0">{
                        err = ErrPolicyExists
                        return false // stop the iteration
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return data.Policy{}, err
        }</span>

        // Compile and validate patterns
        <span class="cov0" title="0">if policy.SpiffeIdPattern != "*" </span><span class="cov0" title="0">{
                idRegex, err := regexp.Compile(policy.SpiffeIdPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return data.Policy{},
                                errors.Join(
                                        ErrInvalidPolicy,
                                        fmt.Errorf("%s: %v", "invalid spiffeid pattern", err),
                                )
                }</span>
                <span class="cov0" title="0">policy.IdRegex = idRegex</span>
        }

        <span class="cov0" title="0">if policy.PathPattern != "*" </span><span class="cov0" title="0">{
                pathRegex, err := regexp.Compile(policy.PathPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return data.Policy{},
                                errors.Join(
                                        ErrInvalidPolicy,
                                        fmt.Errorf("%s: %v", "invalid path pattern", err),
                                )
                }</span>
                <span class="cov0" title="0">policy.PathRegex = pathRegex</span>
        }

        // Generate ID and set creation time
        <span class="cov0" title="0">policy.Id = uuid.New().String()
        if policy.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                policy.CreatedAt = time.Now()
        }</span>

        <span class="cov0" title="0">policies.Store(policy.Id, policy)
        persist.StorePolicy(policy)

        return policy, nil</span>
}

// GetPolicy retrieves a policy by its ID from the policy store.
//
// Parameters:
//   - id: The unique identifier of the policy to retrieve
//
// Returns:
//   - data.Policy: The retrieved policy if found
//   - error: ErrPolicyNotFound if no policy exists with the given ID.
func GetPolicy(id string) (data.Policy, error) <span class="cov0" title="0">{
        if value, exists := policies.Load(id); exists </span><span class="cov0" title="0">{
                return value.(data.Policy), nil
        }</span>

        // Try loading from the cache:
        <span class="cov0" title="0">cachedPolicy := persist.ReadPolicy(id)
        if cachedPolicy == nil </span><span class="cov0" title="0">{
                return data.Policy{}, ErrPolicyNotFound
        }</span>

        // Store in memory for future use
        <span class="cov0" title="0">policies.Store(id, *cachedPolicy)
        return *cachedPolicy, nil</span>
}

// DeletePolicy removes a policy from the system by its ID.
//
// Parameters:
//   - id: The unique identifier of the policy to delete
//
// Returns:
//   - error: ErrPolicyNotFound if no policy exists with the given ID,
//     nil if the deletion was successful
func DeletePolicy(id string) error <span class="cov0" title="0">{
        if _, exists := policies.Load(id); !exists </span><span class="cov0" title="0">{
                return ErrPolicyNotFound
        }</span>

        <span class="cov0" title="0">policies.Delete(id)
        persist.DeletePolicy(id)

        return nil</span>
}

// ListPolicies retrieves all policies from the policy store.
// It iterates through the concurrent map of policies and returns them as a slice.
//
// Returns:
//   - []data.Policy: A slice containing all existing policies. Returns an empty
//     slice if no policies exist. The order of policies in the returned slice
//     is non-deterministic due to the concurrent nature of the underlying store.
func ListPolicies() []data.Policy <span class="cov0" title="0">{
        var result []data.Policy

        policies.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                result = append(result, value.(data.Policy))
                return true
        }</span>)

        <span class="cov0" title="0">return result</span>
}

// ListPoliciesByPath returns all policies that match a specific path pattern.
// It filters the policy store and returns only policies where PathPattern
// exactly matches the provided pattern string.
//
// Parameters:
//   - pathPattern: The exact path pattern to match against policies
//
// Returns:
//   - []data.Policy: A slice of policies with matching PathPattern. Returns an
//     empty slice if no policies match. The order of policies in the returned
//     slice is non-deterministic due to the concurrent nature of the underlying
//     store.
func ListPoliciesByPath(pathPattern string) []data.Policy <span class="cov0" title="0">{
        var result []data.Policy

        policies.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                policy := value.(data.Policy)
                if policy.PathPattern == pathPattern </span><span class="cov0" title="0">{
                        result = append(result, policy)
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">return result</span>
}

// ListPoliciesBySpiffeId returns all policies that match a specific SPIFFE ID
// pattern. It filters the policy store and returns only policies where
// SpiffeIdPattern exactly matches the provided pattern string.
//
// Parameters:
//   - spiffeIdPattern: The exact SPIFFE ID pattern to match against policies
//
// Returns:
//   - []data.Policy: A slice of policies with matching SpiffeIdPattern. Returns
//     an empty slice if no policies match. The order of policies in the returned
//     slice is non-deterministic due to the concurrent nature of the underlying
//     store.
func ListPoliciesBySpiffeId(spiffeIdPattern string) []data.Policy <span class="cov0" title="0">{
        var result []data.Policy

        policies.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                policy := value.(data.Policy)
                if policy.SpiffeIdPattern == spiffeIdPattern </span><span class="cov0" title="0">{
                        result = append(result, policy)
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">return result</span>
}

// ImportPolicies imports a set of policies into the application's memory state.
// It validates each policy, ensuring it has compiled regex patterns before
// storing.
//
// Parameters:
//   - importedPolicies: A map of policy IDs to policy objects
//
// Returns:
//   - error: An error if any policy fails validation
func ImportPolicies(importedPolicies map[string]*data.Policy) <span class="cov0" title="0">{
        for id, policy := range importedPolicies </span><span class="cov0" title="0">{
                // Skip nil policies.
                if policy == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip if ID does not match.
                <span class="cov0" title="0">if policy.Id != id </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Compile patterns if they aren't already compiled
                <span class="cov0" title="0">if policy.SpiffeIdPattern != "*" &amp;&amp; policy.IdRegex == nil </span><span class="cov0" title="0">{
                        idRegex, err := regexp.Compile(policy.SpiffeIdPattern)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip invalid policies.
                                continue</span>
                        }
                        <span class="cov0" title="0">policy.IdRegex = idRegex</span>
                }

                <span class="cov0" title="0">if policy.PathPattern != "*" &amp;&amp; policy.PathRegex == nil </span><span class="cov0" title="0">{
                        pathRegex, err := regexp.Compile(policy.PathPattern)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip invalid policies.
                                continue</span>
                        }
                        <span class="cov0" title="0">policy.PathRegex = pathRegex</span>
                }

                // Store the policy in the global map
                <span class="cov0" title="0">policies.Store(policy.Id, *policy)</span>
        }
}
</pre>
		
		<pre class="file" id="file70" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

import (
        "github.com/spiffe/spike-sdk-go/kv"

        "github.com/spiffe/spike/app/nexus/internal/state/persist"
)

// UpsertSecret stores or updates a secret at the specified path with the
// provided values. It provides thread-safe access to the underlying key-value
// kv.
//
// Parameters:
//   - path: The location where the secret should be stored
//   - values: A map containing the secret key-value pairs to be stored
func UpsertSecret(path string, values map[string]string) <span class="cov0" title="0">{
        secretStoreMu.Lock()
        secretStore.Put(path, values)
        secretStoreMu.Unlock()

        persist.StoreSecret(secretStore, path)
}</span>

// DeleteSecret deletes one or more versions of a secret at the specified path.
// It acquires a mutex lock before performing the deletion to ensure thread
// safety.
//
// Parameters:
//   - path: The path to the secret to be deleted
//   - versions: A slice of version numbers to delete. If empty, deletes the
//     current version only. Version number 0 is the current version.
func DeleteSecret(path string, versions []int) error <span class="cov10" title="5">{
        secretStoreMu.Lock()
        err := secretStore.Delete(path, versions)
        secretStoreMu.Unlock()

        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="4">persist.StoreSecret(secretStore, path)
        return nil</span>
}

// UndeleteSecret restores previously deleted versions of a secret at the
// specified path. It takes a path string identifying the secret's location and
// a slice of version numbers to restore. The function acquires a lock on the
// key-value kv to ensure thread-safe operations during the `undelete` process.
//
// The function operates synchronously and will block until the undelete
// operation is complete. If any specified version numbers don't exist or were
// not previously deleted, those versions will be silently skipped.
//
// Parameters:
//   - path: The path to the secret to be restored
//   - versions: A slice of integer version numbers to restore
//
// Example:
//
//        // Restore versions 1 and 3 of a secret
//        UndeleteSecret("/app/secrets/api-key", []int{1, 3})
func UndeleteSecret(path string, versions []int) error <span class="cov0" title="0">{
        secretStoreMu.Lock()
        err := secretStore.Undelete(path, versions)
        secretStoreMu.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">persist.StoreSecret(secretStore, path)
        return nil</span>
}

// GetSecret retrieves a secret from the specified path and version.
// It provides thread-safe read access to the secret kv.
//
// Parameters:
//   - path: The location of the secret to retrieve
//   - version: The specific version of the secret to fetch
//
// Returns:
//   - map[string]string: The secret key-value pairs
//   - bool: Whether the secret was found
func GetSecret(path string, version int) (map[string]string, error) <span class="cov0" title="0">{
        secretStoreMu.RLock()
        secret, err := secretStore.Get(path, version)
        secretStoreMu.RUnlock()

        if err == nil </span><span class="cov0" title="0">{
                return secret, nil
        }</span>

        <span class="cov0" title="0">cachedSecret := persist.ReadSecret(path, version)
        if cachedSecret == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if version == 0 </span><span class="cov0" title="0">{
                version = cachedSecret.Metadata.CurrentVersion
        }</span>

        <span class="cov0" title="0">secretStoreMu.Lock()
        secretStore.Put(path, cachedSecret.Versions[version].Data)
        secretStoreMu.Unlock()

        return cachedSecret.Versions[version].Data, nil</span>
}

// ImportSecrets imports a set of secrets into the application's memory state.
// Locks the secret store mutex during the operation to ensure thread safety.
func ImportSecrets(secrets map[string]*kv.Value) <span class="cov0" title="0">{
        secretStoreMu.Lock()
        defer secretStoreMu.Unlock()
        secretStore.ImportSecrets(secrets)
}</span>

// GetRawSecret retrieves a secret with metadata from the specified path and
// version. It provides thread-safe read access to the secret kv.
//
// Parameters:
//   - path: The location of the secret to retrieve
//   - version: The specific version of the secret to fetch
//
// Returns:
//   - *kv.Secret: The secret type
//   - bool: Whether the secret was found
func GetRawSecret(path string, version int) (*kv.Value, error) <span class="cov0" title="0">{
        secretStoreMu.RLock()
        secret, err := secretStore.GetRawSecret(path)
        secretStoreMu.RUnlock()

        if err == nil </span><span class="cov0" title="0">{
                return secret, nil
        }</span>

        <span class="cov0" title="0">cachedSecret := persist.ReadSecret(path, version)
        if cachedSecret == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if version == 0 </span><span class="cov0" title="0">{
                version = cachedSecret.Metadata.CurrentVersion
        }</span>

        <span class="cov0" title="0">secretStoreMu.Lock()
        secretStore.Put(path, cachedSecret.Versions[version].Data)
        secretStoreMu.Unlock()

        return cachedSecret, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package base

import (
        "github.com/spiffe/spike-sdk-go/api/entity/data"
)

func contains(permissions []data.PolicyPermission,
        permission data.PolicyPermission) bool <span class="cov0" title="0">{
        for _, p := range permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func hasAllPermissions(
        haves []data.PolicyPermission,
        wants []data.PolicyPermission,
) bool <span class="cov0" title="0">{
        for _, want := range wants </span><span class="cov0" title="0">{
                if !contains(haves, want) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "github.com/spiffe/spike/app/nexus/internal/state/backend"
)

// Backend returns the currently initialized backend storage instance. The
// function is thread-safe through a read mutex lock.
//
// Returns:
//   - A backend.Backend interface pointing to the current backend instance:
//   - memoryBackend for 'memory' store type or unknown types
//   - sqliteBackend for 'sqlite' store type
//
// The return value is determined by env.BackendStoreType():
//   - env.Memory: Returns the memory backend instance
//   - env.Sqlite: Returns the SQLite backend instance
//   - default: Falls back to the memory backend instance
//
// The function is safe for concurrent access as it uses a read mutex to protect
// access to the backend instances. Unlike InitializeBackend, this function
// returns existing instances rather than creating new ones.
func Backend() backend.Backend <span class="cov0" title="0">{
        backendMu.RLock()
        defer backendMu.RUnlock()
        return be
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"
        "encoding/hex"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/app/nexus/internal/state/backend"
        "github.com/spiffe/spike/app/nexus/internal/state/backend/memory"
        "github.com/spiffe/spike/app/nexus/internal/state/backend/sqlite"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

// InitializeSqliteBackend creates and initializes an SQLite backend instance
// using the provided root key for encryption. The backend is configured using
// environment variables for database settings such as directory location,
// connection limits, and journal mode.
//
// Parameters:
//   - rootKey: The encryption key used to secure the SQLite database
//
// Returns:
//   - A backend.Backend interface if successful, nil if initialization fails
//
// The function attempts two main operations:
//  1. Creating the SQLite backend with the provided configuration
//  2. Initializing the backend with a 30-second timeout
//
// If either operation fails, it logs a warning and returns nil. This allows
// the system to continue operating with an in-memory state only. Configuration
// options include:
//   - Database directory and filename
//   - Journal mode settings
//   - Connection pool settings (max open, max idle, lifetime)
//   - Busy timeout settings
func InitializeSqliteBackend(rootKey *[32]byte) backend.Backend <span class="cov0" title="0">{
        const fName = "initializeSqliteBackend"
        const dbName = "spike.db"

        opts := map[backend.DatabaseConfigKey]any{}

        opts[backend.KeyDataDir] = config.SpikeNexusDataFolder()
        opts[backend.KeyDatabaseFile] = dbName
        opts[backend.KeyJournalMode] = env.DatabaseJournalMode()
        opts[backend.KeyBusyTimeoutMs] = env.DatabaseBusyTimeoutMs()
        opts[backend.KeyMaxOpenConns] = env.DatabaseMaxOpenConns()
        opts[backend.KeyMaxIdleConns] = env.DatabaseMaxIdleConns()
        opts[backend.KeyConnMaxLifetimeSeconds] = env.DatabaseConnMaxLifetimeSec()

        // Create SQLite backend configuration
        cfg := backend.Config{
                // Use a copy of the root key as the encryption key.
                // The original root key will be securely zeroed out by the caller.
                EncryptionKey: hex.EncodeToString(rootKey[:]),
                Options:       opts,
        }

        // Initialize SQLite backend
        dbBackend, err := sqlite.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail initialization
                // The system can still work with just in-memory state
                log.Log().Warn(fName,
                        "msg", "Failed to create SQLite backend",
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">ctxC, cancel := context.WithTimeout(
                context.Background(), env.DatabaseInitializationTimeout(),
        )
        defer cancel()

        if err := dbBackend.Initialize(ctxC); err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to initialize SQLite backend",
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">return dbBackend</span>
}

var be backend.Backend

// InitializeBackend creates and returns a backend storage implementation based
// on the configured store type in the environment. The function is thread-safe
// through a mutex lock.
//
// Parameters:
//   - rootKey: The encryption key used for backend initialization (used by
//     SQLite backend)
//
// Returns:
//   - A backend.Backend interface implementation:
//   - memory.NoopStore for 'memory' store type or unknown types
//   - SQLite backend for 'sqlite' store type
//
// The actual backend type is determined by env.BackendStoreType():
//   - env.Memory: Returns a no-op memory store
//   - env.Sqlite: Initializes and returns a SQLite backend
//   - default: Falls back to a no-op memory store
//
// The function is safe for concurrent access as it uses a mutex to protect the
// initialization process.
func InitializeBackend(rootKey *[32]byte) <span class="cov0" title="0">{
        const fName = "initializeBackend"

        log.Log().Info(fName,
                "msg", "Initializing backend", "storeType", env.BackendStoreType())

        backendMu.Lock()
        defer backendMu.Unlock()

        storeType := env.BackendStoreType()

        switch storeType </span>{
        case env.Memory:<span class="cov0" title="0">
                be = &amp;memory.NoopStore{}</span>
        case env.Sqlite:<span class="cov0" title="0">
                be = InitializeSqliteBackend(rootKey)</span>
        default:<span class="cov0" title="0">
                be = &amp;memory.NoopStore{}</span>
        }

        <span class="cov0" title="0">log.Log().Info(fName, "msg", "Backend initialized", "storeType", storeType)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/retry"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/internal/log"
)

// StorePolicy caches a policy in the backend store.
// Memory remains the source of truth - failures are logged but don't affect
// operation.
//
// Parameters:
//   - policy: Policy data to cache
//
// Skips operation if:
//   - Backend is unavailable
//   - Policy ID is empty
func StorePolicy(policy data.Policy) <span class="cov0" title="0">{
        const fName = "storePolicy"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return // No cache available
        }</span>

        <span class="cov0" title="0">if policy.Id == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(),
                env.DatabaseOperationTimeout(),
        )
        defer cancel()

        if err := be.StorePolicy(ctx, policy); err != nil </span><span class="cov0" title="0">{
                // Log error but continue - memory is the source of truth
                log.Log().Warn(fName,
                        "msg", "Failed to cache policy",
                        "id", policy.Id,
                        "err", err.Error(),
                )
        }</span>
}

// ReadAllPolicies retrieves all policies from the backend storage.
// It uses the retry mechanism to handle temporary failures and times out
// after the configured database operation timeout.
// Returns a map of policy IDs to policy objects, or nil if an error occurs.
func ReadAllPolicies() map[string]*data.Policy <span class="cov0" title="0">{
        const fName = "readAllPolicies"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(), env.DatabaseOperationTimeout(),
        )
        defer cancel()

        log.Log().Info(fName, "msg", "Loading policies from cache")
        cachedPolicies, err := retry.Do(ctx, func() (map[string]*data.Policy, error) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Trying to load policies from cache")
                return be.LoadAllPolicies(ctx)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to load policies from cache after retries",
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">return cachedPolicies</span>
}

// DeletePolicy removes a policy from the cache.
// Memory remains the source of truth - failures are logged but don't affect
// operation.
//
// Parameters:
//   - id: Policy ID to remove from cache
//
// Skips operation if:
//   - Backend is unavailable
//   - Id is empty
func DeletePolicy(id string) <span class="cov0" title="0">{
        const fName = "deletePolicy"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(),
                env.DatabaseOperationTimeout(),
        )
        defer cancel()

        if err := be.DeletePolicy(ctx, id); err != nil </span><span class="cov0" title="0">{
                // Log error but continue - memory is the source of truth
                log.Log().Warn(fName,
                        "msg", "Failed to delete policy from cache",
                        "id", id,
                        "err", err.Error(),
                )
        }</span>
}

// ReadPolicy retrieves a policy from the cache with retries.
//
// Parameters:
//   - id: Policy ID to retrieve
//
// Returns:
//   - *data.Policy: Retrieved policy, nil if not found or on error
//
// Uses timeout from env.DatabaseOperationTimeout().
// Logs warnings on failure but continues operation.
func ReadPolicy(id string) *data.Policy <span class="cov0" title="0">{
        const fName = "readPolicy"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(), env.DatabaseOperationTimeout(),
        )
        defer cancel()

        cachedPolicy, err := retry.Do(ctx, func() (*data.Policy, error) </span><span class="cov0" title="0">{
                return be.LoadPolicy(ctx, id)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to load policy from cache after retries",
                        "id", id,
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">return cachedPolicy</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package persist

import (
        "context"

        "github.com/spiffe/spike-sdk-go/kv"
        "github.com/spiffe/spike-sdk-go/retry"

        "github.com/spiffe/spike/app/nexus/internal/env"
        "github.com/spiffe/spike/internal/log"
)

// ReadSecret attempts to retrieve a secret from the backend cache at the
// specified path and version. If no specific version is provided (version = 0),
// it uses the secret's current version.
//
// Parameters:
//   - path: The path where the secret is stored in the cache
//   - version: The specific version of the secret to retrieve.
//     If 0, uses the current version
//
// Returns:
//   - A pointer to the kv.Secret if found and not deleted, nil otherwise
//
// The function returns nil in several cases:
//   - When the backend is not available
//   - When there's an error loading from the cache
//   - When the requested version doesn't exist
//   - When the secret version has been deleted (DeletedTime is set)
func ReadSecret(path string, version int) *kv.Value <span class="cov0" title="0">{
        const fName = "readSecret"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(), env.DatabaseOperationTimeout(),
        )
        defer cancel()

        log.Log().Info(fName, "msg", "Loading secret from cache")
        cachedSecret, err := retry.Do(ctx, func() (*kv.Value, error) </span><span class="cov0" title="0">{
                return be.LoadSecret(ctx, path)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn("readSecret",
                        "msg", "Failed to load secret from cache after retries",
                        "path", path,
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">if cachedSecret != nil </span><span class="cov0" title="0">{
                if version == 0 </span><span class="cov0" title="0">{
                        version = cachedSecret.Metadata.CurrentVersion
                }</span>

                <span class="cov0" title="0">if sv, ok := cachedSecret.Versions[version]; ok &amp;&amp;
                        sv.DeletedTime == nil </span><span class="cov0" title="0">{
                        return cachedSecret
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ReadAllSecrets retrieves all secrets from the backend key-value store.
// It uses an exponential backoff retry mechanism to handle transient errors.
// The function sets a timeout based on the environment's
// DatabaseOperationTimeout.
//
// If the backend is nil or if loading secrets fails after all retry attempts,
// the function returns nil. Any errors during retrieval are logged as warnings.
//
// Returns:
//   - map[string]*kv.Value: A map of all secrets with their keys and values.
//     Returns nil if the backend is unavailable or if loading fails.
func ReadAllSecrets() map[string]*kv.Value <span class="cov0" title="0">{
        const fName = "readAllSecrets"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(), env.DatabaseOperationTimeout(),
        )
        defer cancel()

        log.Log().Info(fName, "msg", "Loading secrets from cache")
        cachedSecrets, err := retry.Do(ctx, func() (map[string]*kv.Value, error) </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", "Trying to load secrets from cache")
                return be.LoadAllSecrets(ctx)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Log().Warn(fName,
                        "msg", "Failed to load secrets from cache after retries",
                        "err", err.Error(),
                )
                return nil
        }</span>

        <span class="cov0" title="0">return cachedSecrets</span>
}

// StoreSecret stores a secret from the key-value store kv to the
// backend cache. It retrieves the secret from the provided path and attempts to
// cache it in a background goroutine. If the backend is not available or if the
// kv operation fails, it will only log a warning since the key-value store kv
// remains the source of truth.
//
// Parameters:
//   - kv: A pointer to the key-value store kv containing the secrets
//   - path: The path where the secret is stored in the key-value store kv
//
// The function does not return any errors since it handles them internally
// through logging. Cache failures are non-fatal as the key-value store kv is
// considered the authoritative data source.
func StoreSecret(kv *kv.KV, path string) <span class="cov0" title="0">{
        const fName = "storeSecret"

        be := Backend()
        if be == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Get the full secret for caching
        <span class="cov0" title="0">secret, err := kv.GetRawSecret(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Info(fName, "msg", err.Error())
        }</span>

        <span class="cov0" title="0">if secret == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(
                context.Background(),
                env.DatabaseOperationTimeout(),
        )
        defer cancel()

        if err := be.StoreSecret(ctx, path, *secret); err != nil </span><span class="cov0" title="0">{
                // Log error but continue - memory is the source of truth
                log.Log().Warn(fName,
                        "msg", "Failed to cache secret",
                        "path", path,
                        "err", err.Error(),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package main

import (
        "context"
        "fmt"
        "os"

        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffe"

        "github.com/spiffe/spike/app/spike/internal/cmd"
        "github.com/spiffe/spike/app/spike/internal/env"
        "github.com/spiffe/spike/internal/log"
)

func main() <span class="cov0" title="0">{
        if !mem.Lock() </span><span class="cov0" title="0">{
                if env.ShowMemoryWarning() </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintln(os.Stderr, `
Memory locking is not available.
Consider disabling swap to enhance security.
 `); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("failed to write to stderr: ", err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        source, spiffeId, err := spiffe.Source(ctx, spiffe.EndpointSocket())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
        <span class="cov0" title="0">defer spiffe.CloseSource(source)

        cmd.Initialize(source, spiffeId)
        cmd.Execute()</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package cmd

import (
        "fmt"
        "os"

        "github.com/spiffe/go-spiffe/v2/workloadapi"

        "github.com/spiffe/spike/app/spike/internal/cmd/operator"
        "github.com/spiffe/spike/app/spike/internal/cmd/policy"
        "github.com/spiffe/spike/app/spike/internal/cmd/secret"
)

// Initialize sets up the CLI command structure with a workload API X.509
// source.
//
// It creates and configures the following commands:
//   - get: Retrieves secrets with optional version specification
//   - delete: Removes specified versions of secrets
//   - undelete: Restores specified versions of secrets
//   - initialization: Initializes the secret management system
//   - put: Stores new secrets
//   - list: Displays available secrets
//
// Parameters:
//   - source: An X.509 source for workload API authentication
//
// Each command is added to the root command with appropriate flags and options:
//   - get: --version, -v (int) for specific version retrieval
//   - delete: --versions, -v (string) for comma-separated version list
//   - undelete: --versions, -v (string) for comma-separated version list
//
// Example usage:
//
//        source := workloadapi.NewX509Source(...)
//        Initialize(source)
func Initialize(source *workloadapi.X509Source, spiffeId string) <span class="cov0" title="0">{
        rootCmd.AddCommand(policy.NewPolicyCommand(source, spiffeId))
        rootCmd.AddCommand(secret.NewSecretCommand(source, spiffeId))
        rootCmd.AddCommand(operator.NewOperatorCommand(source, spiffeId))
}</span>

// Execute runs the root command and handles any errors that occur.
// If an error occurs during execution, it prints the error and exits
// with status code 1.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                if _, err2 := fmt.Fprintf(os.Stderr, "%v\n", err); err2 != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to write to stderr: ", err2.Error())
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
)

// NewOperatorCommand creates a new cobra.Command for managing SPIKE admin
// operations. It initializes an "operator" command with subcommands for
// recovery and restore operations.
//
// Parameters:
//   - source: An X509Source used for SPIFFE authentication
//   - spiffeId: The SPIFFE ID associated with the operator
//
// Returns:
//   - *cobra.Command: A configured cobra command for operator management
func NewOperatorCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "operator",
                Short: "Manage admin operations",
        }

        cmd.AddCommand(newOperatorRecoverCommand(source, spiffeId))
        cmd.AddCommand(newOperatorRestoreCommand(source, spiffeId))

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "encoding/hex"
        "fmt"
        "github.com/spiffe/spike/app/spike/internal/env"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"
        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffeid"

        "github.com/spiffe/spike/app/spike/internal/trust"
        "github.com/spiffe/spike/internal/config"
        "github.com/spiffe/spike/internal/log"
)

// newOperatorRecoverCommand creates a new cobra command for recovery operations
// on SPIKE Nexus.
//
// This function creates a command that allows privileged operators with the
// 'recover' role to retrieve recovery shards from a healthy SPIKE Nexus system.
// The retrieved shards are saved to the configured recovery directory and can
// be used to restore the system in case of a catastrophic failure.
//
// Parameters:
//   - source *workloadapi.X509Source: The X.509 source for SPIFFE
//     authentication.
//   - spiffeId string: The SPIFFE ID of the caller for role-based access
//     control.
//
// Returns:
//   - *cobra.Command: A cobra command that implements the recovery
//     functionality.
//
// The command performs the following operations:
//   - Verifies the caller has the 'recover' role, aborting otherwise.
//   - Authenticates the recovery request.
//   - Retrieves recovery shards from the SPIKE API.
//   - Cleans the recovery directory of any previous recovery files.
//   - Saves the retrieved shards as text files in the recovery directory.
//   - Provides instructions to the operator about securing the recovery shards.
//
// The command will abort with a fatal error if:
//   - The caller lacks the required 'recover' role.
//   - The API call to retrieve shards fails.
//   - Fewer than 2 shards are retrieved.
//   - It fails to read or clean the recovery directory.
func newOperatorRecoverCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var recoverCmd = &amp;cobra.Command{
                Use:   "recover",
                Short: "Recover SPIKE Nexus (do this while SPIKE Nexus is healthy)",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if !spiffeid.IsPilotRecover(env.TrustRoot(), spiffeId) </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("  You need to have a `recover` role to use this command.")
                                fmt.Println(
                                        "  Please run `./hack/bare-metal/entry/spire-server-entry-recover-register.sh`")
                                fmt.Println("  with necessary privileges to assign this role.")
                                fmt.Println("")
                                log.FatalLn("Aborting.")
                        }</span>

                        <span class="cov0" title="0">trust.AuthenticateRecover(spiffeId)

                        api := spike.NewWithSource(source)

                        shards, err := api.Recover()
                        // Security: clean the shards when we no longer need them.
                        defer func() </span><span class="cov0" title="0">{
                                for _, shard := range shards </span><span class="cov0" title="0">{
                                        mem.ClearRawBytes(shard)
                                }</span>
                        }()

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.FatalLn(err.Error())
                        }</span>

                        <span class="cov0" title="0">if shards == nil </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("  No shards found.")
                                fmt.Println("  Cannot save recovery shards.")
                                fmt.Println("  Please try again later.")
                                fmt.Println("  If the problem persists, check SPIKE logs.")
                                fmt.Println("")

                                return
                        }</span>

                        <span class="cov0" title="0">for _, shard := range shards </span><span class="cov0" title="0">{
                                emptyShard := true
                                for _, v := range shard </span><span class="cov0" title="0">{
                                        if v != 0 </span><span class="cov0" title="0">{
                                                emptyShard = false
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if emptyShard </span><span class="cov0" title="0">{
                                        fmt.Println("")
                                        fmt.Println("  Empty shard found.")
                                        fmt.Println("  Cannot save recovery shards.")
                                        fmt.Println("  Please try again later.")
                                        fmt.Println("  If the problem persists, check SPIKE logs.")
                                }</span>
                        }

                        // Creates the folder if it does not exist.
                        <span class="cov0" title="0">recoverDir := config.SpikePilotRecoveryFolder()

                        // Clean the path to normalize it
                        cleanPath, err := filepath.Abs(filepath.Clean(recoverDir))
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("    Error resolving recovery directory path.")
                                fmt.Println("    " + err.Error())
                                fmt.Println("")
                                log.FatalLn("Aborting.")
                        }</span>

                        // Verify the path exists and is a directory
                        <span class="cov0" title="0">fileInfo, err := os.Stat(cleanPath)
                        if err != nil || !fileInfo.IsDir() </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("    Invalid recovery directory path.")
                                fmt.Println("    Path does not exist or is not a directory.")
                                fmt.Println("")
                                log.FatalLn("Aborting.")
                        }</span>

                        // Ensure the cleaned path doesn't contain suspicious components
                        // This helps catch any attempts at path traversal that survived cleaning
                        <span class="cov0" title="0">if strings.Contains(cleanPath, "..") ||
                                strings.Contains(cleanPath, "./") ||
                                strings.Contains(cleanPath, "//") </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("    Invalid recovery directory path.")
                                fmt.Println("    Path contains suspicious components.")
                                fmt.Println("")
                                log.FatalLn("Aborting.")
                        }</span>

                        // Ensure the recover directory is clean by
                        // deleting any existing recovery files.
                        // We are NOT warning the user about this operation because
                        // the admin ought to have securely backed up the shards and
                        // deleted them from the recover directory anyway.
                        <span class="cov0" title="0">if _, err := os.Stat(recoverDir); err == nil </span><span class="cov0" title="0">{
                                files, err := os.ReadDir(recoverDir)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Failed to read recover directory %s: %s\n",
                                                recoverDir, err.Error())
                                        log.FatalLn(err.Error())
                                }</span>

                                <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                                        if file.Name() != "" &amp;&amp; filepath.Ext(file.Name()) == ".txt" &amp;&amp;
                                                strings.HasPrefix(file.Name(), "spike.recovery") </span><span class="cov0" title="0">{
                                                filePath := filepath.Join(recoverDir, file.Name())
                                                err := os.Remove(filePath)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf("Failed to delete old recovery file %s: %s\n",
                                                                filePath, err.Error())
                                                }</span>
                                        }
                                }
                        }

                        // Save each shard to a file
                        <span class="cov0" title="0">for i, shard := range shards </span><span class="cov0" title="0">{
                                filePath := fmt.Sprintf("%s/spike.recovery.%d.txt", recoverDir, i)

                                encodedShard := hex.EncodeToString(shard[:])

                                out := fmt.Sprintf("spike:%d:%s", i, encodedShard)

                                // 0600 to be more restrictive.
                                err := os.WriteFile(filePath, []byte(out), 0600)

                                // Security: Hint gc to reclaim memory.
                                encodedShard = "" // nolint:ineffassign
                                out = ""          // nolint:ineffassign
                                runtime.GC()

                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Failed to save shard %d: %s\n", i, err.Error())
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Println("")
                        fmt.Println("  SPIKE Recovery shards saved to the recovery directory:")
                        fmt.Println("  " + recoverDir)
                        fmt.Println("")
                        fmt.Println("  Please make sure that:")
                        fmt.Println("    1. You encrypt these shards and keep them safe.")
                        fmt.Println("    2. Securely erase the shards from the")
                        fmt.Println("       recovery directory after you encrypt them")
                        fmt.Println("       and save them to a safe location.")
                        fmt.Println("")
                        fmt.Println(
                                "  If you lose these shards, you will not be able to recover")
                        fmt.Println(
                                "  SPIKE Nexus in the unlikely event of a total system crash.")
                        fmt.Println("")</span>
                },
        }

        <span class="cov0" title="0">return recoverCmd</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package operator

import (
        "encoding/hex"
        "fmt"
        "github.com/spiffe/spike/app/spike/internal/env"
        "os"
        "strconv"
        "strings"
        "syscall"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"
        "github.com/spiffe/spike-sdk-go/security/mem"
        "github.com/spiffe/spike-sdk-go/spiffeid"
        "golang.org/x/term"

        "github.com/spiffe/spike/app/spike/internal/trust"
        "github.com/spiffe/spike/internal/log"
)

// newOperatorRestoreCommand creates a new cobra command for restoration
// operations on SPIKE Nexus.
//
// This function creates a command that allows privileged operators with the
// 'restore' role to restore SPIKE Nexus after a system failure. The command
// accepts recovery shards interactively and initiates the restoration process.
//
// Parameters:
//   - source *workloadapi.X509Source: The X.509 source for SPIFFE
//     authentication.
//   - spiffeId string: The SPIFFE ID of the caller for role-based access
//     control.
//
// Returns:
//   - *cobra.Command: A cobra command that implements the restoration
//     functionality.
//
// The command performs the following operations:
//   - Verifies the caller has the 'restore' role, aborting otherwise.
//   - Authenticates the restoration request.
//   - Prompts the user to enter a recovery shard (input is hidden for
//     security).
//   - Sends the shard to the SPIKE API to contribute to restoration.
//   - Reports the status of the restoration process to the user.
//
// The command will abort with a fatal error if:
//   - The caller lacks the required 'restore' role.
//   - There's an error reading the recovery shard from input.
//   - The API call to restore using the shard fails.
//   - No status is returned from the restoration attempt.
//
// If restoration is incomplete (more shards are needed), the command displays
// the current count of collected shards and instructs the user to run the
// command again to provide additional shards.
func newOperatorRestoreCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var restoreCmd = &amp;cobra.Command{
                Use:   "restore",
                Short: "Restore SPIKE Nexus (do this if SPIKE Nexus cannot auto-recover)",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if !spiffeid.IsPilotRestore(env.TrustRoot(), spiffeId) </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println(
                                        "  You need to have a `restore` role to use this command.")
                                fmt.Println(
                                        "  Please run `./hack/bare-metal/entry/spire-server-entry-restore-register.sh`")
                                fmt.Println("  with necessary privileges to assign this role.")
                                fmt.Println("")
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">trust.AuthenticateRestore(spiffeId)

                        fmt.Println("(your input will be hidden as you paste/type it)")
                        fmt.Print("Enter recovery shard: ")
                        shard, err := term.ReadPassword(syscall.Stdin)
                        if err != nil </span><span class="cov0" title="0">{
                                _, e := fmt.Fprintf(os.Stderr, "Error reading shard: %v\n", err)
                                if e != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }

                        <span class="cov0" title="0">api := spike.NewWithSource(source)

                        var shardToRestore [32]byte

                        // shard is in `spike:$id:$base64` format
                        shardParts := strings.SplitN(string(shard), ":", 3)
                        if len(shardParts) != 3 </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println(
                                        "Invalid shard format. Expected format: `spike:$id:$secret`.",
                                )
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">index := shardParts[1]
                        hexData := shardParts[2]

                        // 32 bytes encoded in hex should be 64 characters
                        if len(hexData) != 64 </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println(
                                        "Invalid hex shard length:", len(hexData),
                                        "(expected 64 characters).",
                                        "Did you miss some characters when pasting?",
                                )
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">decodedShard, err := hex.DecodeString(hexData)

                        // Security: Use `defer` for cleanup to ensure it happens even in
                        // error paths
                        defer func() </span><span class="cov0" title="0">{
                                mem.ClearBytes(shard)
                                mem.ClearBytes(decodedShard)
                                mem.ClearRawBytes(&amp;shardToRestore)
                        }</span>()

                        // Security: reset shard immediately after use.
                        <span class="cov0" title="0">mem.ClearBytes(shard)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("Failed to decode recovery shard: ", err.Error())
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">if len(decodedShard) != 32 </span><span class="cov0" title="0">{
                                // Security: reset decodedShard immediately after use.
                                mem.ClearBytes(decodedShard)

                                fmt.Println("")
                                fmt.Println("Invalid recovery shard length: ", len(decodedShard))
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">for i := 0; i &lt; 32; i++ </span><span class="cov0" title="0">{
                                shardToRestore[i] = decodedShard[i]
                        }</span>

                        // Security: reset decodedShard immediately after use.
                        <span class="cov0" title="0">mem.ClearBytes(decodedShard)

                        ix, err := strconv.Atoi(index)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("Invalid shard index: ", err.Error())
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">status, err := api.Restore(ix, &amp;shardToRestore)

                        // Security: reset shardToRestore immediately after recovery.
                        mem.ClearRawBytes(&amp;shardToRestore)

                        if err != nil </span><span class="cov0" title="0">{
                                log.FatalLn(err.Error())
                        }</span>

                        <span class="cov0" title="0">if status == nil </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("Didn't get any status while trying to restore SPIKE.")
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">if status.Restored </span><span class="cov0" title="0">{
                                fmt.Println("")
                                fmt.Println("  SPIKE is now restored and ready to use.")
                                fmt.Println(
                                        "  Please run `./hack/bare-metal/entry/spire-server-entry-su-register.sh`")
                                fmt.Println(
                                        "  with necessary privileges to start using SPIKE as a superuser.")
                                fmt.Println("")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("")
                                fmt.Println(" Shards collected: ", status.ShardsCollected)
                                fmt.Println(" Shards remaining: ", status.ShardsRemaining)
                                fmt.Println(
                                        " Please run `spike operator restore` " +
                                                "again to provide the remaining shards.")
                                fmt.Println("")
                        }</span>
                },
        }

        <span class="cov0" title="0">return restoreCmd</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newPolicyCreateCommand creates a new Cobra command for policy creation.
// It allows users to create new policies via the command line by specifying
// the policy name, SPIFFE ID pattern, path pattern, and permissions.
//
// The command requires an X509Source for SPIFFE authentication and validates
// that the system is initialized before creating a policy.
//
// Parameters:
//   - source: SPIFFE X.509 SVID source for authentication
//   - spiffeId: The SPIFFE ID to authenticate with
//
// Returns:
//   - *cobra.Command: Configured Cobra command for policy creation
//
// Command flags:
//   - --name: Name of the policy (required)
//   - --spiffeid: SPIFFE ID pattern for workload matching (required)
//   - --path: Path pattern for access control (required)
//   - --permissions: Comma-separated list of permissions (required)
//
// Valid permissions:
//   - read: Permission to read secrets
//   - write: Permission to create, update, or delete secrets
//   - list: Permission to list resources
//   - super: Administrative permissions
//
// Example usage:
//
//        spike policy create \
//            --name "web-service-policy" \
//            --spiffeid "spiffe://example.org/web-service/*" \
//            --path "/api/v1/*" \
//            --permissions "read,write"
//
// The command will:
//  1. Validate that all required flags are provided
//  2. Check if the system is initialized
//  3. Validate permissions and convert to the expected format
//  4. Check if a policy with the same name already exists
//  5. Create the policy using the provided parameters
//
// Error conditions:
//   - Missing required flags
//   - Invalid permissions specified
//   - Policy with the same name already exists
//   - System not initialized (requires running 'spike init' first)
//   - Invalid SPIFFE ID pattern
//   - Policy creation failure

func newPolicyCreateCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var (
                name            string
                pathPattern     string
                spiffeIdPattern string
                permsStr        string
        )

        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new policy",
                Long: `Create a new policy that grants specific permissions to workloads.

        Example:
        spike policy create --name=db-access 
          --path="db/*" --spiffeid="spiffe://example.org/service/*" 
          --permissions="read,write"

        Valid permissions: read, write, list, super`,
                Args: cobra.NoArgs,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{

                        // Check if all required flags are provided
                        var missingFlags []string
                        if name == "" </span><span class="cov0" title="0">{
                                missingFlags = append(missingFlags, "name")
                        }</span>
                        <span class="cov0" title="0">if pathPattern == "" </span><span class="cov0" title="0">{
                                missingFlags = append(missingFlags, "path")
                        }</span>
                        <span class="cov0" title="0">if spiffeIdPattern == "" </span><span class="cov0" title="0">{
                                missingFlags = append(missingFlags, "spiffeid")
                        }</span>
                        <span class="cov0" title="0">if permsStr == "" </span><span class="cov0" title="0">{
                                missingFlags = append(missingFlags, "permissions")
                        }</span>

                        <span class="cov0" title="0">if len(missingFlags) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Println("Error: all flags are required")
                                for _, flag := range missingFlags </span><span class="cov0" title="0">{
                                        fmt.Printf("  --%s is missing\n", flag)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">trust.Authenticate(spiffeId)
                        api := spike.NewWithSource(source)

                        // Validate permissions
                        permissions, err := validatePermissions(permsStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: %v\n", err)
                                return
                        }</span>

                        // Check if a policy with this name already exists
                        <span class="cov0" title="0">exists, err := checkPolicyNameExists(api, name)
                        if handleAPIError(err) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                fmt.Printf("Error: A policy with name '%s' already exists\n", name)
                                return
                        }</span>

                        // Create policy
                        <span class="cov0" title="0">err = api.CreatePolicy(name, spiffeIdPattern, pathPattern, permissions)
                        if handleAPIError(err) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Policy created successfully")</span>
                },
        }

        // Define flags
        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;name, "name", "", "Policy name (required)")
        cmd.Flags().StringVar(&amp;pathPattern, "path", "",
                "Resource path pattern, e.g., '/secrets/*' (required)")
        cmd.Flags().StringVar(&amp;spiffeIdPattern, "spiffeid", "",
                "SPIFFE ID pattern, e.g., 'spiffe://example.org/service/*' (required)")
        cmd.Flags().StringVar(&amp;permsStr, "permissions", "",
                "Comma-separated permissions: read, write, list, super (required)")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newPolicyDeleteCommand creates a new Cobra command for policy deletion.
// It allows users to delete existing policies by providing either the policy ID
// as a command line argument or the policy name with the --name flag.
//
// The command requires an X509Source for SPIFFE authentication and validates
// that the system is initialized before attempting to delete a policy.
//
// Parameters:
//   - source: SPIFFE X.509 SVID source for authentication
//   - spiffeId: The SPIFFE ID to authenticate with
//
// Returns:
//   - *cobra.Command: Configured Cobra command for policy deletion
//
// Command usage:
//
//        delete [policy-id] [flags]
//
// Arguments:
//   - policy-id: The unique identifier of the policy to delete (optional if --name is provided)
//
// Flags:
//   - --name: Policy name to look up (alternative to policy ID)
//
// Example usage:
//
//        spike policy delete policy-123
//        spike policy delete --name=web-service-policy
//
// The command will:
//  1. Check if the system is initialized
//  2. Get the policy ID either from arguments or by looking up the policy name
//  3. Prompt the user to confirm deletion
//  4. If confirmed, attempt to delete the policy with the specified ID
//  5. Confirm successful deletion or report any errors
//
// Error conditions:
//   - Neither policy ID argument nor --name flag provided
//   - Policy not found by ID or name
//   - User cancels the operation
//   - System not initialized (requires running 'spike init' first)
//   - Insufficient permissions
//   - Policy deletion failure
//
// Note: This operation cannot be undone. The policy will be permanently removed
// from the system. The command requires confirmation before proceeding.
func newPolicyDeleteCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "delete [policy-id]",
                Short: "Delete a policy",
                Long: `Delete a policy by ID or name.
        
        You can provide either:
        - A policy ID as an argument: spike policy delete abc123
        - A policy name with the --name flag: spike policy delete --name=my-policy`,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)
                        api := spike.NewWithSource(source)

                        policyId, err := sendGetPolicyIdRequest(cmd, args, api)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: %v\n", err)
                                return
                        }</span>

                        // Confirm deletion
                        <span class="cov0" title="0">fmt.Printf("Are you sure you want to delete policy with ID '%s'? (y/N): ", policyId)
                        reader := bufio.NewReader(os.Stdin)
                        confirm, _ := reader.ReadString('\n')
                        confirm = strings.TrimSpace(confirm)

                        if confirm != "y" &amp;&amp; confirm != "Y" </span><span class="cov0" title="0">{
                                fmt.Println("Operation canceled")
                                return
                        }</span>

                        <span class="cov0" title="0">err = api.DeletePolicy(policyId)
                        if handleAPIError(err) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Policy deleted successfully")</span>
                },
        }

        <span class="cov0" title="0">addNameFlag(cmd)
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"
        "strings"

        "github.com/spiffe/spike/app/spike/internal/stdout"
)

// handleAPIError processes API errors and prints appropriate messages.
// It helps standardize error handling across policy commands.
//
// Parameters:
//   - err: The error returned from an API call
//
// Returns:
//   - bool: true if an error was handled, false if no error
//
// Usage example:
//
//        policies, err := api.ListPolicies()
//        if handleAPIError(err) {
//            return
//        }
func handleAPIError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if err.Error() == "not ready" </span><span class="cov0" title="0">{
                stdout.PrintNotReady()
                return true
        }</span>

        <span class="cov0" title="0">if strings.Contains(err.Error(), "unexpected end of JSON") ||
                strings.Contains(err.Error(), "parsing") </span><span class="cov0" title="0">{
                fmt.Println("Error: Failed to parse API response. " +
                        "The server may be unavailable or returned an invalid response.")
                fmt.Printf("Technical details: %v\n", err)
                return true
        }</span>

        <span class="cov0" title="0">fmt.Printf("Error: %v\n", err)
        return true</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/spf13/cobra"
        spike "github.com/spiffe/spike-sdk-go/api"
)

// findPolicyByName searches for a policy with the given name and returns its
// ID. It returns an error if the policy cannot be found or if there's an issue
// with the API call.
//
// Parameters:
//   - api: The SPIKE API client
//   - name: The policy name to search for
//
// Returns:
//   - string: The policy ID if found
//   - error: An error if the policy is not found or there's an API issue
func findPolicyByName(api *spike.Api, name string) (string, error) <span class="cov0" title="0">{
        policies, err := api.ListPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if policies != nil </span><span class="cov0" title="0">{
                for _, policy := range *policies </span><span class="cov0" title="0">{
                        if policy.Name == name </span><span class="cov0" title="0">{
                                return policy.Id, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no policy found with name '%s'", name)</span>
}

const uuidRegex = `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`

func validUuid(uuid string) bool <span class="cov0" title="0">{
        r := regexp.MustCompile(uuidRegex)
        return r.MatchString(strings.ToLower(uuid))
}</span>

// sendGetPolicyIdRequest gets the policy ID either from command arguments or the name flag.
// If args contains a policy ID, it returns that. If the name flag is provided,
// it looks up the policy by name and returns its ID. If neither is provided,
// it returns an error.
//
// Parameters:
//   - cmd: The Cobra command containing the flags
//   - args: Command arguments that might contain the policy ID
//   - api: The SPIKE API client
//
// Returns:
//   - string: The policy ID
//   - error: An error if the policy cannot be found or if neither ID nor name
//     is provided
func sendGetPolicyIdRequest(cmd *cobra.Command,
        args []string, api *spike.Api,
) (string, error) <span class="cov0" title="0">{
        var policyId string

        name, _ := cmd.Flags().GetString("name")

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                policyId = args[0]

                if !validUuid(policyId) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid policy ID '%s'", policyId)
                }</span>

        } else<span class="cov0" title="0"> if name != "" </span><span class="cov0" title="0">{
                id, err := findPolicyByName(api, name)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">policyId = id</span>
        } else<span class="cov0" title="0"> {
                return "", fmt.Errorf(
                        "either policy ID as argument or --name flag is required",
                )
        }</span>

        <span class="cov0" title="0">return policyId, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import "github.com/spf13/cobra"

// addFormatFlag adds a format flag to the given command to allow specifying
// the output format (human or JSON).
//
// Parameters:
//   - cmd: The Cobra command to add the flag to
func addFormatFlag(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Flags().String("format", "human",
                "Output format: 'human' or 'json'")
}</span>

// addNameFlag adds a name flag to the given command to allow specifying
// a policy by name instead of by ID.
//
// Parameters:
//   - cmd: The Cobra command to add the flag to
func addNameFlag(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Flags().String("name", "",
                "Policy name to look up (alternative to policy ID)")
}</span>

// addSpiffeIdFlag adds a spiffeId flag to the given command to allow filtering
// policies by SPIFFE ID pattern.
//
// Parameters:
//   - cmd: The Cobra command to add the flag to
func addSpiffeIdFlag(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Flags().String("spiffeId", "",
                "Filter policies by SPIFFE ID pattern")
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "github.com/spiffe/spike-sdk-go/api/entity/data"
)

// formatPoliciesOutput formats the output of policies based on the format flag.
// It supports "human" (default) and "json" formats. For human format, it creates
// a readable tabular representation. For JSON format, it marshals the policies
// to indented JSON.
//
// If the format flag is invalid, it returns an error message.
// If the "policies" list is empty, it returns an appropriate message based on
// the format.
//
// Parameters:
//   - cmd: The Cobra command containing the format flag
//   - policies: The policies to format
//
// Returns:
//   - string: The formatted output or error message
func formatPoliciesOutput(cmd *cobra.Command, policies *[]data.Policy) string <span class="cov0" title="0">{
        format, _ := cmd.Flags().GetString("format")

        // Validate format
        if format != "" &amp;&amp; format != "human" &amp;&amp; format != "json" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error: Invalid format '%s'."+
                        " Valid formats are: human, json", format)
        }</span>

        // Check if "policies" is nil or empty
        <span class="cov0" title="0">isEmptyList := policies == nil || len(*policies) == 0

        if format == "json" </span><span class="cov0" title="0">{
                if isEmptyList </span><span class="cov0" title="0">{
                        // Return an empty array instead of null for an empty list in JSON format
                        return "[]"
                }</span>

                <span class="cov0" title="0">output, err := json.MarshalIndent(policies, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Error formatting output: %v", err)
                }</span>
                <span class="cov0" title="0">return string(output)</span>
        }

        // Default human-readable format
        <span class="cov0" title="0">if isEmptyList </span><span class="cov0" title="0">{
                return "No policies found"
        }</span>

        // The rest of the function remains the same:
        <span class="cov0" title="0">var result strings.Builder
        result.WriteString("POLICIES\n========\n\n")

        for _, policy := range *policies </span><span class="cov0" title="0">{
                result.WriteString(fmt.Sprintf("ID: %s\n", policy.Id))
                result.WriteString(fmt.Sprintf("Name: %s\n", policy.Name))
                result.WriteString(fmt.Sprintf("SPIFFE ID Pattern: %s\n",
                        policy.SpiffeIdPattern))
                result.WriteString(fmt.Sprintf("Path Pattern: %s\n",
                        policy.PathPattern))

                perms := make([]string, 0, len(policy.Permissions))
                for _, p := range policy.Permissions </span><span class="cov0" title="0">{
                        perms = append(perms, string(p))
                }</span>
                <span class="cov0" title="0">result.WriteString(fmt.Sprintf("Permissions: %s\n",
                        strings.Join(perms, ", ")))
                result.WriteString(fmt.Sprintf("Created At: %s\n",
                        policy.CreatedAt.Format(time.RFC3339)))
                if policy.CreatedBy != "" </span><span class="cov0" title="0">{
                        result.WriteString(fmt.Sprintf("Created By: %s\n", policy.CreatedBy))
                }</span>
                <span class="cov0" title="0">result.WriteString("--------\n\n")</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

// formatPolicy formats a single policy based on the format flag.
// It converts the policy to a slice and reuses the formatPoliciesOutput
// function for consistent formatting.
//
// Parameters:
//   - cmd: The Cobra command containing the format flag
//   - policy: The policy to format
//
// Returns:
//   - string: The formatted policy or error message
func formatPolicy(cmd *cobra.Command, policy *data.Policy) string <span class="cov0" title="0">{
        format, _ := cmd.Flags().GetString("format")

        // Validate format
        if format != "" &amp;&amp; format != "human" &amp;&amp; format != "json" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error: Invalid format '%s'. "+
                        "Valid formats are: human, json", format)
        }</span>

        <span class="cov0" title="0">if policy == nil </span><span class="cov0" title="0">{
                return "No policy found"
        }</span>

        <span class="cov0" title="0">if format == "json" </span><span class="cov0" title="0">{
                output, err := json.MarshalIndent(policy, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Error formatting output: %v", err)
                }</span>
                <span class="cov0" title="0">return string(output)</span>
        }

        // Human-readable format for single policy
        <span class="cov0" title="0">var result strings.Builder
        result.WriteString("POLICY DETAILS\n=============\n\n")

        result.WriteString(fmt.Sprintf("ID: %s\n", policy.Id))
        result.WriteString(fmt.Sprintf("Name: %s\n", policy.Name))
        result.WriteString(fmt.Sprintf("SPIFFE ID Pattern: %s\n",
                policy.SpiffeIdPattern))
        result.WriteString(fmt.Sprintf("Path Pattern: %s\n",
                policy.PathPattern))

        perms := make([]string, 0, len(policy.Permissions))
        for _, p := range policy.Permissions </span><span class="cov0" title="0">{
                perms = append(perms, string(p))
        }</span>

        <span class="cov0" title="0">result.WriteString(fmt.Sprintf("Permissions: %s\n",
                strings.Join(perms, ", ")))
        result.WriteString(fmt.Sprintf("Created At: %s\n",
                policy.CreatedAt.Format(time.RFC3339)))

        if policy.CreatedBy != "" </span><span class="cov0" title="0">{
                result.WriteString(fmt.Sprintf("Created By: %s\n", policy.CreatedBy))
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newPolicyGetCommand creates a new Cobra command for retrieving policy
// details. It fetches and displays the complete information about a specific
// policy by ID or name.
//
// The command requires an X509Source for SPIFFE authentication and validates
// that the system is initialized before retrieving policy information.
//
// Parameters:
//   - source: SPIFFE X.509 SVID source for authentication
//   - spiffeId: The SPIFFE ID to authenticate with
//
// Returns:
//   - *cobra.Command: Configured Cobra command for policy retrieval
//
// Command usage:
//
//        get [policy-id] [flags]
//
// Arguments:
//   - policy-id: The unique identifier of the policy to retrieve
//     (optional if --name is provided)
//
// Flags:
//   - --name: Policy name to look up (alternative to policy ID)
//   - --format: Output format ("human" or "json", default is "human")
//
// Example usage:
//
//        spike policy get abc123
//        spike policy get --name=web-service-policy
//        spike policy get abc123 --format=json
//
// Example output for human format:
//
//        POLICY DETAILS
//        =============
//
//        ID: policy-123
//        Name: web-service-policy
//        SPIFFE ID Pattern: spiffe://example.org/web-service/*
//        Path Pattern: /api/v1/*
//        Permissions: read, write
//        Created At: 2024-01-01T00:00:00Z
//        Created By: user-abc
//
// Example output for JSON format:
//
//        {
//          "id": "policy-123",
//          "name": "web-service-policy",
//          "spiffeIdPattern": "spiffe://example.org/web-service/*",
//          "pathPattern": "/api/v1/*",
//          "permissions": ["read", "write"],
//          "createdAt": "2024-01-01T00:00:00Z",
//          "createdBy": "user-abc"
//        }
//
// The command will:
//  1. Check if the system is initialized
//  2. Get the policy ID either from arguments or by looking up the policy name
//  3. Retrieve the policy with the specified ID
//  4. Format the policy details based on the format flag
//  5. Display the formatted output
//
// Error conditions:
//   - Neither policy ID argument nor --name flag provided
//   - Policy not found by ID or name
//   - Invalid format specified
//   - System not initialized (requires running 'spike init' first)
//   - Insufficient permissions
func newPolicyGetCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "get [policy-id]",
                Short: "Get policy details",
                Long: `Get detailed information about a policy by ID or name.

        You can provide either:
        - A policy ID as an argument: spike policy get abc123
        - A policy name with the --name flag: spike policy get --name=my-policy

        Use --format=json to get the output in JSON format.`,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)
                        api := spike.NewWithSource(source)

                        // If the first argument is provided without `--name` flag, it could be
                        // misinterpreted as trying to use policy name directly
                        if len(args) &gt; 0 &amp;&amp; !cmd.Flags().Changed("name") </span><span class="cov0" title="0">{
                                fmt.Println("Note: To look up a policy by name, use --name flag:")
                                fmt.Printf("  spike policy get --name=%s\n\n", args[0])
                                fmt.Printf("Attempting to use '%s' as policy ID...\n", args[0])
                        }</span>

                        <span class="cov0" title="0">policyId, err := sendGetPolicyIdRequest(cmd, args, api)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: %v\n", err)
                                return
                        }</span>

                        <span class="cov0" title="0">policy, err := api.GetPolicy(policyId)
                        if handleAPIError(err) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if policy == nil </span><span class="cov0" title="0">{
                                fmt.Println("Error: Got empty response from server")
                                return
                        }</span>

                        <span class="cov0" title="0">output := formatPolicy(cmd, policy)
                        fmt.Println(output)</span>
                },
        }

        <span class="cov0" title="0">addNameFlag(cmd)
        addFormatFlag(cmd)
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newPolicyListCommand creates a new Cobra command for listing policies.
// It retrieves and displays policies in the system, with optional filtering
// by SPIFFE ID pattern.
//
// The command requires an X509Source for SPIFFE authentication and validates
// that the system is initialized before listing policies.
//
// Parameters:
//   - source: SPIFFE X.509 SVID source for authentication
//   - spiffeId: The SPIFFE ID to authenticate with
//
// Returns:
//   - *cobra.Command: Configured Cobra command for policy listing
//
// Command usage:
//
//        list [--format=&lt;format&gt;] [--spiffeId=&lt;pattern&gt;]
//
// Flags:
//   - --format: Output format ("human" or "json", default is "human")
//   - --spiffeId: Filter policies by SPIFFE ID pattern
//
// Example usage:
//
//        spike policy list
//        spike policy list --format=json
//        spike policy list --spiffeId="spiffe://example.org/web-service/*"
//
// Example output for human format:
//
//        POLICIES
//        ========
//
//        ID: policy-123
//        Name: web-service-policy
//        SPIFFE ID Pattern: spiffe://example.org/web-service/*
//        Path Pattern: /api/v1/*
//        Permissions: read, write
//        Created At: 2024-01-01T00:00:00Z
//        Created By: user-abc
//        --------
//
// Example output for JSON format:
//
//        [
//          {
//            "id": "policy-123",
//            "name": "web-service-policy",
//            "spiffeIdPattern": "spiffe://example.org/web-service/*",
//            "pathPattern": "/api/v1/*",
//            "permissions": ["read", "write"],
//            "createdAt": "2024-01-01T00:00:00Z",
//            "createdBy": "user-abc"
//          }
//        ]
//
// The command will:
//  1. Check if the system is initialized
//  2. Retrieve all existing policies
//  3. Format the policies based on the format flag
//  4. Display the formatted output
//
// Error conditions:
//   - System not initialized (requires running 'spike init' first)
//   - An invalid format specified
//   - Insufficient permissions
//   - Policy retrieval failure
//
// Note: If no policies exist, it returns "No policies found" for human format
// or "[]" for JSON format.
func newPolicyListCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List policies, optionally filtered by SPIFFE ID pattern",
                Args:  cobra.NoArgs,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)
                        api := spike.NewWithSource(source)

                        // Get the spiffeId flag value and pass it to the API
                        spiffeIdPattern, _ := cmd.Flags().GetString("spiffeId")

                        policies, err := api.ListPolicies(spiffeIdPattern)
                        if handleAPIError(err) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">output := formatPoliciesOutput(cmd, policies)
                        fmt.Println(output)</span>
                },
        }

        <span class="cov0" title="0">addFormatFlag(cmd)
        addSpiffeIdFlag(cmd)
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package policy

import (
        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
)

// NewPolicyCommand creates a new top-level command for working with policies.
// It acts as a parent for all policy-related subcommands: create, list, get, and delete.
//
// The policy commands allow for managing access control policies that define
// which workloads can access which resources based on SPIFFE ID patterns and
// path patterns.
//
// Parameters:
//   - source: SPIFFE X.509 SVID source for authentication
//   - spiffeId: The SPIFFE ID to authenticate with
//
// Returns:
//   - *cobra.Command: Configured top-level Cobra command for policy management
//
// Available subcommands:
//   - create: Create a new policy
//   - list: List all existing policies
//   - get: Get details of a specific policy by ID or name
//   - delete: Delete a policy by ID or name
//
// Example usage:
//
//        spike policy list
//        spike policy get abc123
//        spike policy get --name=my-policy
//        spike policy create --name=new-policy --path="/secret/*" --spiffeid="spiffe://example.org/*" --permissions=read,write
//        spike policy delete abc123
//        spike policy delete --name=my-policy
//
// Each subcommand has its own set of flags and arguments. See the individual
// command documentation for details.
func NewPolicyCommand(source *workloadapi.X509Source, spiffeId string) *cobra.Command <span class="cov0" title="0">{
    cmd := &amp;cobra.Command{
        Use:   "policy",
        Short: "Manage policies",
        Long: `Manage access control policies.

                Policies control which workloads can access which secrets.
                Each policy defines a set of permissions granted to workloads
                matching a SPIFFE ID pattern for resources matching a path pattern.

                Available subcommands:
                create    Create a new policy
                list      List all policies
                get       Get details of a specific policy
                delete    Delete a policy`,
    }

    // Add subcommands
    cmd.AddCommand(newPolicyListCommand(source, spiffeId))
    cmd.AddCommand(newPolicyGetCommand(source, spiffeId))
    cmd.AddCommand(newPolicyCreateCommand(source, spiffeId))
    cmd.AddCommand(newPolicyDeleteCommand(source, spiffeId))

    return cmd
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package policy

import (
        "fmt"
        "strings"

        spike "github.com/spiffe/spike-sdk-go/api"
        "github.com/spiffe/spike-sdk-go/api/entity/data"
)

// validatePermissions validates policy permissions from a comma-separated string
// and returns a slice of PolicyPermission values. Only "read", "write", "list",
// and "super" are valid permissions. It returns an error if any permission is
// invalid or if the string contains no valid permissions.
//
// Parameters:
//   - permsStr: Comma-separated string of permissions (e.g., "read,write,list")
//
// Returns:
//   - []data.PolicyPermission: Validated policy permissions
//   - error: An error if any permission is invalid
func validatePermissions(permsStr string) ([]data.PolicyPermission, error) <span class="cov0" title="0">{
        validPerms := map[string]bool{
                "read":  true,
                "write": true,
                "list":  true,
                "super": true,
        }

        var permissions []string
        for _, p := range strings.Split(permsStr, ",") </span><span class="cov0" title="0">{
                perm := strings.TrimSpace(p)
                if perm != "" </span><span class="cov0" title="0">{
                        permissions = append(permissions, perm)
                }</span>
        }

        <span class="cov0" title="0">perms := make([]data.PolicyPermission, 0, len(permissions))
        for _, perm := range permissions </span><span class="cov0" title="0">{
                if _, ok := validPerms[perm]; !ok </span><span class="cov0" title="0">{
                        validPermsList := "read, write, list, super"
                        return nil, fmt.Errorf(
                                "invalid permission '%s'. Valid permissions are: %s",
                                perm, validPermsList)
                }</span>
                <span class="cov0" title="0">perms = append(perms, data.PolicyPermission(perm))</span>
        }

        <span class="cov0" title="0">if len(perms) == 0 </span><span class="cov0" title="0">{
                return nil,
                        fmt.Errorf("no valid permissions specified. " +
                                "Valid permissions are: read, write, list, super")
        }</span>

        <span class="cov0" title="0">return perms, nil</span>
}

// checkPolicyNameExists checks if a policy with the given name already exists.
//
// Parameters:
//   - api: The SPIKE API client
//   - name: The policy name to check
//
// Returns:
//   - bool: true if a policy with the name exists, false otherwise
//   - error: An error if there's an issue with the API call
func checkPolicyNameExists(api *spike.Api, name string) (bool, error) <span class="cov0" title="0">{
        policies, err := api.ListPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if policies != nil </span><span class="cov0" title="0">{
                for _, policy := range *policies </span><span class="cov0" title="0">{
                        if policy.Name == name </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

const validPath = `^[a-zA-Z0-9._\-/()?+*|[\]{}\\]+$`

// Helper function to validate secret paths
func validSecretPath(path string) bool <span class="cov0" title="0">{
        r := regexp.MustCompile(validPath)
        return r.MatchString(path)
}</span>

// newSecretDeleteCommand creates and returns a new cobra.Command for deleting
// secrets. It configures a command that allows users to delete one or more
// versions of a secret at a specified path.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// The command accepts a single argument:
//   - path: Location of the secret to delete
//
// Flags:
//   - --versions, -v (string): Comma-separated list of version numbers to
//     delete
//   - "0" or empty: Deletes current version only (default)
//   - "1,2,3": Deletes specific versions
//
// Returns:
//   - *cobra.Command: Configured delete command
//
// Example Usage:
//
//        spike secret delete secret/apocalyptica           # Deletes current version
//        spike secret delete secret/apocalyptica -v 1,2,3  # Deletes specific versions
//        spike secret delete secret/apocalyptica -v 0,1,2  # Deletes current version plus 1,2
//
// The command performs trust to ensure:
//   - Exactly one path argument is provided
//   - Version numbers are valid non-negative integers
//   - Version strings are properly formatted
func newSecretDeleteCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var deleteCmd = &amp;cobra.Command{
                Use:   "delete &lt;path&gt;",
                Short: "Delete secrets at the specified path",
                Long: `Delete secrets at the specified path. 
Specify versions using -v or --versions flag with comma-separated values.
Version 0 refers to the current/latest version.
If no version is specified, defaults to deleting the current version.

Examples:
  spike secret delete secret/apocalyptica          # Deletes current version
  spike secret delete secret/apocalyptica -v 1,2,3 # Deletes specific versions
  spike secret delete secret/apocalyptica -v 0,1,2 # Deletes current version plus versions 1 and 2`,
                Args: cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        path := args[0]
                        versions, _ := cmd.Flags().GetString("versions")

                        if !validSecretPath(path) </span><span class="cov0" title="0">{
                                fmt.Printf("Error: invalid secret path: %s\n", path)
                                return
                        }</span>

                        <span class="cov0" title="0">if versions == "" </span><span class="cov0" title="0">{
                                versions = "0"
                        }</span>

                        // Parse and validate versions
                        <span class="cov0" title="0">versionList := strings.Split(versions, ",")
                        for _, v := range versionList </span><span class="cov0" title="0">{
                                version, err := strconv.Atoi(strings.TrimSpace(v))

                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error: invalid version number: %s\n", v)
                                        return
                                }</span>

                                <span class="cov0" title="0">if version &lt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf(
                                                "Error: version numbers cannot be negative: %s\n", v,
                                        )
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">var vv []int
                        for _, v := range versionList </span><span class="cov0" title="0">{
                                iv, err := strconv.Atoi(v)
                                if err == nil </span><span class="cov0" title="0">{
                                        vv = append(vv, iv)
                                }</span>
                        }
                        <span class="cov0" title="0">if vv == nil </span><span class="cov0" title="0">{
                                vv = []int{}
                        }</span>

                        <span class="cov0" title="0">err := api.DeleteSecretVersions(path, vv)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("Error: %v\n", err)
                                return</span>
                        }

                        <span class="cov0" title="0">fmt.Println("OK")</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.Flags().StringP("versions", "v", "0",
                "Comma-separated list of versions to delete")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "encoding/json"
        "fmt"
        "slices"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"
        "gopkg.in/yaml.v3"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newSecretGetCommand creates and returns a new cobra.Command for retrieving
// secrets. It configures a command that fetches and displays secret data from a
// specified path.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// The command accepts a single argument:
//   - path: Location of the secret to retrieve
//
// Flags:
//   - --version, -v (int): Specific version of the secret to retrieve
//     (default 0) where 0 represents the current version
//
// Returns:
//   - *cobra.Command: Configured get command
//
// The command will:
//  1. Verify SPIKE initialization status via admin token
//  2. Retrieve the secret from the specified path and version
//  3. Display all key-value pairs in the secret's data field
//
// Error cases:
//   - SPIKE not initialized: Prompts user to run 'spike init'
//   - Secret not found: Displays an appropriate message
//   - Read errors: Displays an error message
func newSecretGetCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var getCmd = &amp;cobra.Command{
                Use:   "get &lt;path&gt; [key]",
                Short: "Get secrets from the specified path",
                Args:  cobra.RangeArgs(1, 2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        path := args[0]
                        version, _ := cmd.Flags().GetInt("version")
                        format, _ := cmd.Flags().GetString("format")

                        if !slices.Contains([]string{"plain", "yaml", "json", "y", "p", "j"}, format) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid format specified: %s", format)
                        }</span>

                        <span class="cov0" title="0">if !validSecretPath(path) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid secret path: %s", path)
                        }</span>

                        <span class="cov0" title="0">secret, err := api.GetSecretVersion(path, version)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return fmt.Errorf("server not ready")
                                }</span>

                                <span class="cov0" title="0">return fmt.Errorf("failure reading secret: %v", err.Error())</span>
                        }

                        <span class="cov0" title="0">if secret == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Secret not found")
                        }</span>

                        <span class="cov0" title="0">if secret.Data == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("secret has no data")
                        }</span>

                        <span class="cov0" title="0">d := secret.Data
                        found := false
                        if format == "plain" || format == "p" </span><span class="cov0" title="0">{
                                for k, v := range d </span><span class="cov0" title="0">{
                                        if len(args) &lt; 2 || args[1] == "" </span><span class="cov0" title="0">{
                                                fmt.Printf("%s: %s\n", k, v)
                                                found = true
                                        }</span> else<span class="cov0" title="0"> if args[1] == k </span><span class="cov0" title="0">{
                                                fmt.Printf("%s\n", v)
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Key not found")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                var b []byte
                                if len(args) &lt; 2 || args[1] == "" </span><span class="cov0" title="0">{
                                        if format == "yaml" || format == "y" </span><span class="cov0" title="0">{
                                                b, err = yaml.Marshal(d)
                                        }</span> else<span class="cov0" title="0"> {
                                                b, err = json.MarshalIndent(d, "", "    ")
                                        }</span>
                                        <span class="cov0" title="0">found = true</span>
                                } else<span class="cov0" title="0"> {
                                        for k, v := range d </span><span class="cov0" title="0">{
                                                if args[1] == k </span><span class="cov0" title="0">{
                                                        if format == "yaml" || format == "y" </span><span class="cov0" title="0">{
                                                                b, err = yaml.Marshal(v)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                b, err = json.Marshal(v)
                                                        }</span>
                                                        <span class="cov0" title="0">found = true
                                                        break</span>
                                                }
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to marshal data: %w", err)
                                }</span>
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Key not found")
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s\n", string(b))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">getCmd.Flags().IntP("version", "v", 0, "Specific version to retrieve")
        getCmd.Flags().StringP("format", "f", "plain", "Format to use. Valid options: plain, p, yaml, y, json, j")

        return getCmd</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

const notFoundMessage = "No secrets found."

// newSecretListCommand creates and returns a new cobra.Command for listing all
// secret paths. It configures a command that retrieves and displays all
// available secret paths from the system.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// Returns:
//   - *cobra.Command: Configured list command
//
// The command will:
//  1. Make a network request to retrieve all available secret paths
//  2. Display the results in a formatted list
//  3. Show "No secrets found" if the system is empty
//
// Output format:
//
//        Secrets:
//        - secret/path1
//        - secret/path2
//        - secret/path3
//
// Note: Requires an initialized SPIKE system and valid authentication
func newSecretListCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var listCmd = &amp;cobra.Command{
                Use:   "list",
                Short: "List all secret paths",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        keys, err := api.ListSecretKeys()
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return
                                }</span>

                                <span class="cov0" title="0">fmt.Println("Error listing secret keys:", err)
                                return</span>
                        }
                        <span class="cov0" title="0">if keys == nil </span><span class="cov0" title="0">{
                                fmt.Println(notFoundMessage)
                                return
                        }</span>

                        <span class="cov0" title="0">if len(*keys) == 0 </span><span class="cov0" title="0">{
                                fmt.Println(notFoundMessage)
                                return
                        }</span>

                        <span class="cov0" title="0">for _, key := range *keys </span><span class="cov0" title="0">{
                                fmt.Printf("- %s\n", key)
                        }</span>
                },
        }

        <span class="cov0" title="0">return listCmd</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newSecretMetadataGetCommand creates and returns a new cobra.Command for
// retrieving secrets. It configures a command that fetches and displays secret
// data from a specified path.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// The command accepts a single argument:
//   - path: Location of the secret to retrieve
//
// Flags:
//   - --version, -v (int): Specific version of the secret to retrieve
//     (default 0) where 0 represents the current version
//
// Returns:
//   - *cobra.Command: Configured get command
//
// The command will:
//  1. Verify SPIKE initialization status via admin token
//  2. Retrieve the secret metadata from the specified path and version
//  3. Display all metadata fields and secret versions
//
// Error cases:
//   - SPIKE not initialized: Prompts user to run 'spike init'
//   - Secret not found: Displays an appropriate message
//   - Read errors: Displays an error message
func newSecretMetadataGetCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "metadata",
                Short: "Manage secret metadata",
        }

        var getCmd = &amp;cobra.Command{
                Use:   "get &lt;path&gt;",
                Short: "Gets secret metadata from the specified path",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        path := args[0]
                        version, _ := cmd.Flags().GetInt("version")

                        secret, err := api.GetSecretMetadata(path, version)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return
                                }</span>

                                <span class="cov0" title="0">fmt.Println("Error reading secret:", err.Error())
                                return</span>
                        }

                        <span class="cov0" title="0">if secret == nil </span><span class="cov0" title="0">{
                                fmt.Println("Secret not found.")
                                return
                        }</span>

                        <span class="cov0" title="0">printSecretResponse(secret)</span>
                },
        }

        <span class="cov0" title="0">getCmd.Flags().IntP("version", "v", 0, "Specific version to retrieve")

        cmd.AddCommand(getCmd)

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
)

// NewSecretCommand creates a new Cobra command for managing secrets.
func NewSecretCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        // trust.Authenticate(spiffeId)

        cmd := &amp;cobra.Command{
                Use:   "secret",
                Short: "Manage secrets",
        }

        // Add subcommands to the policy command
        cmd.AddCommand(newSecretDeleteCommand(source, spiffeId))
        cmd.AddCommand(newSecretUndeleteCommand(source, spiffeId))
        cmd.AddCommand(newSecretListCommand(source, spiffeId))
        cmd.AddCommand(newSecretGetCommand(source, spiffeId))
        cmd.AddCommand(newSecretMetadataGetCommand(source, spiffeId))
        cmd.AddCommand(newSecretPutCommand(source, spiffeId))

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package secret

import (
        "fmt"
        "strings"
        "time"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
)

// formatTime formats a time.Time object into a readable string.
// The format used is "2006-01-02 15:04:05 MST".
func formatTime(t time.Time) string <span class="cov0" title="0">{
        return t.Format("2006-01-02 15:04:05 MST")
}</span>

// printSecretResponse prints secret metadata
func printSecretResponse(response *data.SecretMetadata) <span class="cov0" title="0">{
        printSeparator := func() </span><span class="cov0" title="0">{
                fmt.Println(strings.Repeat("-", 50))
        }</span>

        <span class="cov0" title="0">hasMetadata := response.Metadata != (data.SecretMetaDataContent{})
        if hasMetadata </span><span class="cov0" title="0">{
                fmt.Println("\nMetadata:")
                printSeparator()
                fmt.Printf("Current Version    : %d\n", response.Metadata.CurrentVersion)
                fmt.Printf("Oldest Version     : %d\n", response.Metadata.OldestVersion)
                fmt.Printf("Created Time       : %s\n", formatTime(response.Metadata.CreatedTime))
                fmt.Printf("Last Updated       : %s\n", formatTime(response.Metadata.UpdatedTime))
                fmt.Printf("Max Versions       : %d\n", response.Metadata.MaxVersions)
                printSeparator()
        }</span>

        <span class="cov0" title="0">if len(response.Versions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nSecret Versions:")
                printSeparator()

                for version, versionData := range response.Versions </span><span class="cov0" title="0">{
                        fmt.Printf("Version %d:\n", version)
                        fmt.Printf("  Created: %s\n", formatTime(versionData.CreatedTime))
                        if versionData.DeletedTime != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  Deleted: %s\n", formatTime(*versionData.DeletedTime))
                        }</span>
                        <span class="cov0" title="0">printSeparator()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file97" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newSecretPutCommand creates and returns a new cobra.Command for storing
// secrets. It configures a command that stores key-value pairs as a secret at a
// specified path.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// Returns:
//   - *cobra.Command: Configured put command
//
// Arguments:
//  1. path: Location where the secret will be stored
//  2. key=value pairs: One or more key-value pairs in the format "key=value"
//
// Example Usage:
//
//        spike secret put secret/myapp username=admin password=secret
//        spike secret put secret/config host=localhost port=8080
//
// The command will:
//  1. Verify SPIKE initialization status via admin token
//  2. Parse all key-value pairs from arguments
//  3. Store the collected key-value pairs at the specified path
//
// Error cases:
//   - SPIKE not initialized: Prompts user to run 'spike init'
//   - Invalid key-value format: Reports the malformed pair
//   - Network/storage errors: Displays error message
//
// Note: Current admin token verification will be replaced with
// temporary token authentication in future versions
func newSecretPutCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var putCmd = &amp;cobra.Command{
                Use:   "put &lt;path&gt; &lt;key=value&gt;...",
                Short: "Put secrets at the specified path",
                Args:  cobra.MinimumNArgs(2),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        path := args[0]

                        if !validSecretPath(path) </span><span class="cov0" title="0">{
                                fmt.Printf("Error: invalid secret path: %s\n", path)
                                return
                        }</span>

                        <span class="cov0" title="0">kvPairs := args[1:]
                        values := make(map[string]string)
                        for _, kv := range kvPairs </span><span class="cov0" title="0">{
                                if !strings.Contains(kv, "=") </span><span class="cov0" title="0">{
                                        fmt.Printf("Error: invalid key-value pair format: %s\n", kv)
                                        continue</span>
                                }
                                <span class="cov0" title="0">kvs := strings.Split(kv, "=")
                                values[kvs[0]] = kvs[1]</span>
                        }

                        <span class="cov0" title="0">if len(values) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("OK")
                                return
                        }</span>

                        <span class="cov0" title="0">err := api.PutSecret(path, values)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("Error: %v\n", err)
                                return</span>
                        }

                        <span class="cov0" title="0">fmt.Println("OK")</span>
                },
        }

        <span class="cov0" title="0">return putCmd</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package secret

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        spike "github.com/spiffe/spike-sdk-go/api"

        "github.com/spiffe/spike/app/spike/internal/stdout"
        "github.com/spiffe/spike/app/spike/internal/trust"
)

// newSecretUndeleteCommand creates and returns a new cobra.Command for
// restoring deleted secrets. It configures a command that allows users to
// restore one or more previously deleted versions of a secret at a specified
// path.
//
// Parameters:
//   - source: X.509 source for workload API authentication
//
// The command accepts a single argument:
//   - path: Location of the secret to restore
//
// Flags:
//   - --versions, -v (string): Comma-separated list of version numbers to
//     restore
//   - "0" or empty: Restores current version only (default)
//   - "1,2,3": Restores specific versions
//
// Returns:
//   - *cobra.Command: Configured undelete command
//
// Example Usage:
//
//        spike secret undelete secret/ella           # Restores current version
//        spike secret undelete secret/ella -v 1,2,3  # Restores specific versions
//        spike secret undelete secret/ella -v 0,1,2  # Restores current version plus 1,2
//
// The command performs trust to ensure:
//   - Exactly one path argument is provided
//   - Version numbers are valid non-negative integers
//   - Version strings are properly formatted
//
// Note: Command currently provides feedback about intended operations
// but actual restoration functionality is pending implementation
func newSecretUndeleteCommand(
        source *workloadapi.X509Source, spiffeId string,
) *cobra.Command <span class="cov0" title="0">{
        var undeleteCmd = &amp;cobra.Command{
                Use:   "undelete &lt;path&gt;",
                Short: "Undelete secrets at the specified path",
                Long: `Undelete secrets at the specified path. 
Specify versions using -v or --versions flag with comma-separated values.
Version 0 refers to the current/latest version.
If no version is specified, defaults to undeleting the current version.

Examples:
  spike secret undelete secret/ella           # Undeletes current version
  spike secret undelete secret/ella -v 1,2,3  # Undeletes specific versions
  spike secret undelete secret/ella -v 0,1,2  # Undeletes current version plus versions 1 and 2`,
                Args: cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        trust.Authenticate(spiffeId)

                        api := spike.NewWithSource(source)

                        path := args[0]

                        if !validSecretPath(path) </span><span class="cov0" title="0">{
                                fmt.Printf("Error: invalid secret path: %s\n", path)
                                return
                        }</span>

                        <span class="cov0" title="0">versions, _ := cmd.Flags().GetString("versions")
                        if versions == "" </span><span class="cov0" title="0">{
                                versions = "0"
                        }</span>

                        // Parse and validate versions
                        <span class="cov0" title="0">versionList := strings.Split(versions, ",")
                        for _, v := range versionList </span><span class="cov0" title="0">{
                                version, err := strconv.Atoi(strings.TrimSpace(v))

                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error: invalid version number: %s\n", v)
                                        return
                                }</span>

                                <span class="cov0" title="0">if version &lt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf(
                                                "Error: version numbers cannot be negative: %s\n", v,
                                        )
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">var vv []int
                        for _, v := range versionList </span><span class="cov0" title="0">{
                                iv, err := strconv.Atoi(v)
                                if err == nil </span><span class="cov0" title="0">{
                                        vv = append(vv, iv)
                                }</span>
                        }
                        <span class="cov0" title="0">if vv == nil </span><span class="cov0" title="0">{
                                vv = []int{}
                        }</span>

                        <span class="cov0" title="0">err := api.UndeleteSecret(path, vv)
                        if err != nil </span><span class="cov0" title="0">{
                                if err.Error() == "not ready" </span><span class="cov0" title="0">{
                                        stdout.PrintNotReady()
                                        return
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("Error: %v\n", err)
                                return</span>
                        }

                        <span class="cov0" title="0">fmt.Println("OK")</span>
                },
        }

        <span class="cov0" title="0">undeleteCmd.Flags().StringP("versions", "v", "0",
                "Comma-separated list of versions to undelete")

        return undeleteCmd</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import "os"

// TrustRoot returns the trust root domain(s) for the application.
//
// It retrieves the trust root from the SPIKE_TRUST_ROOT environment variable.
// If the environment variable is not set, it returns the default value
// "spike.ist". The return value can be a comma-delimited string of multiple
// trust root domains.
//
// Returns:
//   - A string containing one or more trust root domains, comma-delimited if
//     multiple
func TrustRoot() string <span class="cov0" title="0">{
        tr := os.Getenv("SPIKE_TRUST_ROOT")
        if tr == "" </span><span class="cov0" title="0">{
                return "spike.ist"
        }</span>
        <span class="cov0" title="0">return tr</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package env

import (
        "os"
        "strings"
)

// ShowMemoryWarning returns whether to display a warning when the system
// cannot lock memory based on the SPIKE_PILOT_SHOW_MEMORY_WARNING environment
// variable.
//
// The function reads the SPIKE_PILOT_SHOW_MEMORY_WARNING environment variable
// and returns:
//   - false if the variable is not set (default behavior)
//   - true if the variable is set to "true" (case-insensitive)
//   - false for any other value
//
// The environment variable value is trimmed of whitespace and converted to
// lowercase before comparison.
//
// This warning is typically shown when memory locking fails, which could
// impact security-sensitive operations that require pages to remain in RAM.
func ShowMemoryWarning() bool <span class="cov0" title="0">{
        s := os.Getenv("SPIKE_PILOT_SHOW_MEMORY_WARNING")
        s = strings.ToLower(strings.TrimSpace(s))
        if s == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return s == "true"</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package stdout provides utilities for printing formatted messages to
// standard output. It contains functions for displaying notification and
// status messages to users.
package stdout

import "fmt"
import "os"

// PrintNotReady prints a message indicating that SPIKE is not initialized
// and provides instructions for troubleshooting and recovery.
// The message includes suggestions to wait, check logs, and information about
// manual bootstrapping if the initialization problem persists.
func PrintNotReady() <span class="cov0" title="0">{
        if _, err := fmt.Fprintln(os.Stderr, `!
!        SPIKE is not initialized.
!        Wait a few seconds and try again.
!        Also, check out SPIKE Nexus logs.
!
!        If the problem persists, you may need to
!        manually bootstrap via 'spike operator restore'.
!
!        Please check out https://spike.ist/ for additional
!        recovery and restoration information.
!`); err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to write to stderr: ", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package trust provides functions and utilities to manage and validate trust
// relationships using the SPIFFE standard. This package includes methods for
// authenticating SPIFFE IDs, ensuring secure identity verification in
// distributed systems.
package trust

import (
        svid "github.com/spiffe/spike-sdk-go/spiffeid"
        "github.com/spiffe/spike/app/spike/internal/env"

        "github.com/spiffe/spike/internal/log"
)

// Authenticate verifies if the provided SPIFFE ID belongs to a pilot instance.
// Logs a fatal error and exits if verification fails.
func Authenticate(spiffeid string) <span class="cov0" title="0">{
        if !svid.IsPilot(env.TrustRoot(), spiffeid) </span><span class="cov0" title="0">{
                log.Log().Error(
                        "Authenticate: You need a 'super user' SPIFFE ID to use this command.",
                )
                log.FatalF(
                        "Authenticate: You are not authorized to use this command (%s).\n",
                        spiffeid,
                )
        }</span>
}

// AuthenticateRecover validates the SPIFFE ID for the recover role and exits
// the application if it does not match the recover SPIFFE ID.
func AuthenticateRecover(spiffeid string) <span class="cov0" title="0">{
        if !svid.IsPilotRecover(env.TrustRoot(), spiffeid) </span><span class="cov0" title="0">{
                log.Log().Error(
                        "AuthenticateRecover: You need a 'recover' SPIFFE ID to use this command.",
                )
                log.FatalF(
                        "AuthenticateRecover: You are not authorized to use this command (%s).\n",
                        spiffeid,
                )
        }</span>
}

// AuthenticateRestore verifies if the given SPIFFE ID is valid for restoration.
// Logs a fatal error and exits if the SPIFFE ID validation fails.
func AuthenticateRestore(spiffeid string) <span class="cov0" title="0">{
        if !svid.IsPilotRestore(env.TrustRoot(), spiffeid) </span><span class="cov0" title="0">{
                log.Log().Error(
                        "AuthenticateRestore: You need a 'restore' SPIFFE ID to use this command.",
                )
                log.FatalF(
                        "AuthenticateRecover: You are not authorized to use this command (%s).\n",
                        spiffeid,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package main

import (
        "crypto/rand"
        "fmt"
        "github.com/google/goexpect"
        "log"
        "math/big"
        "regexp"
        "time"
)

func generatePassword(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()_+-=[]"
        password := make([]byte, length)
        for i := range password </span><span class="cov0" title="0">{
                n, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                password[i] = charset[n.Int64()]
        }</span>
        <span class="cov0" title="0">return string(password)</span>
}

func main() <span class="cov0" title="0">{
        password := generatePassword(20)
        timeout := 2 * time.Minute
        spike := "/home/volkan/Desktop/WORKSPACE/spike/spike"

        // Initialize SPIKE.

        child, _, err := expect.Spawn(spike+" initialization", -1)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func(child *expect.GExpect) </span><span class="cov0" title="0">{
                _ = child.Close()
        }</span>(child)

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("Enter admin password:"), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err = child.Send(password + "\n")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("Confirm admin password:"), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err = child.Send(password + "\n")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("SPIKE system initialization completed."), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("SPIKE initialized with password: %s\n", password)

        // Log in to SPIKE

        child, _, err = expect.Spawn(spike+" login", -1)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func(child *expect.GExpect) </span><span class="cov0" title="0">{
                _ = child.Close()
        }</span>(child)

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("Enter admin password:"), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err = child.Send(password + "\n")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return
        }</span>

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("Login successful."), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Put a secret

        <span class="cov0" title="0">child, _, err = expect.Spawn(spike+" put /tenants/acme/db username=root password=SPIKERocks", -1)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("OK"), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Get the secret

        <span class="cov0" title="0">child, _, err = expect.Spawn(spike+" get /tenants/acme/db", -1)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">_, _, err = child.Expect(regexp.MustCompile("password: SPIKERocks"), timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Something went wrong!", err.Error())
        }</span>

        <span class="cov0" title="0">log.Println("Everything is awesome!")</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

// Package config provides configuration-related functionalities
// for the SPIKE system, including version constants and directory
// management for storing encrypted backups and secrets securely.
package config

import (
        "os"
        "path"
        "path/filepath"
)

// #region spike:build

// These constants are automatically updated during the release process.
// Please do not modify them manually.

const SpikeNexusVersion = "0.4.1"
const SpikePilotVersion = "0.4.1"
const SpikeKeeperVersion = "0.4.1"

// #endregion

const spikeNexusTombstoneFile = "spike.nexus.bootstrap.tombstone"

// SpikeNexusTombstonePath returns the full file path for the tombstone file.
// This file is used to indicate the bootstrap status of SPIKE Nexus.
// It combines the data folder path with the tombstone file name.
func SpikeNexusTombstonePath() string <span class="cov0" title="0">{
        return path.Join(
                SpikeNexusDataFolder(), spikeNexusTombstoneFile,
        )
}</span>

// SpikeNexusDataFolder returns the path to the directory where Nexus stores
// its encrypted backup for its secrets and other data.
func SpikeNexusDataFolder() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                homeDir = "/tmp"
        }</span>

        <span class="cov0" title="0">spikeDir := filepath.Join(homeDir, ".spike")

        // Create the directory if it doesn't exist
        // 0700 because we want to restrict access to the directory
        // but allow the user to create db files in it.
        err = os.MkdirAll(spikeDir+"/data", 0700)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // The data dir is not configurable for security reasons.
        <span class="cov0" title="0">return filepath.Join(spikeDir, "/data")</span>
}

// SpikePilotRecoveryFolder returns the path to the directory where the
// recovery shards will be stored as a result of the `spike recover`
// command.
func SpikePilotRecoveryFolder() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                homeDir = "/tmp"
        }</span>

        <span class="cov0" title="0">spikeDir := filepath.Join(homeDir, ".spike")

        // Create the directory if it doesn't exist
        // 0700 because we want to restrict access to the directory
        // but allow the user to create recovery files in it.
        err = os.MkdirAll(spikeDir+"/recover", 0700)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // The data dir is not configurable for security reasons.
        <span class="cov0" title="0">return filepath.Join(spikeDir, "/recover")</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package log

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"
)

type AuditState string

const AuditEntryCreated AuditState = "audit-entry-created"
const AuditErrored AuditState = "audit-errored"
const AuditSuccess AuditState = "audit-success"

type AuditAction string

const AuditEnter AuditAction = "enter"
const AuditExit AuditAction = "exit"
const AuditCreate AuditAction = "create"
const AuditList AuditAction = "list"
const AuditDelete AuditAction = "delete"
const AuditRead AuditAction = "read"
const AuditUndelete AuditAction = "undelete"
const AuditFallback AuditAction = "fallback"
const AuditBlocked AuditAction = "blocked"

// AuditEntry represents a single audit log entry containing information about
// user actions within the system.
type AuditEntry struct {
        // Component is the name of the component that performed the action.
        Component string

        // TrailId is a unique identifier for the audit trail
        TrailId string

        // Timestamp indicates when the audited action occurred
        Timestamp time.Time

        // UserId identifies the user who performed the action
        UserId string

        // Action describes what operation was performed
        Action AuditAction

        // Path is the URL path of the request
        Path string

        // Resource identifies the object or entity acted upon
        Resource string

        // SessionID links the action to a specific user session
        SessionID string

        // State represents the state of the resource after the action
        State AuditState

        // Err contains an error message if the action failed
        Err string

        // Duration is the time taken to process the action
        Duration time.Duration
}

type AuditLogLine struct {
        Timestamp  time.Time  `json:"time"`
        AuditEntry AuditEntry `json:"audit"`
}

// Audit logs an audit entry as JSON to the standard log output.
// If JSON marshaling fails, it logs an error using the structured logger
// but continues execution.
func Audit(entry AuditEntry) <span class="cov0" title="0">{
        audit := AuditLogLine{
                Timestamp:  time.Now(),
                AuditEntry: entry,
        }

        body, err := json.Marshal(audit)
        if err != nil </span><span class="cov0" title="0">{
                // If you cannot audit, crashing is the best option.
                FatalLn("Audit",
                        "msg", "Problem marshalling audit entry",
                        "err", err.Error())
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(string(body))</span>
}

// AuditRequest logs the details of an HTTP request and updates the audit entry
// with the specified action. It captures the HTTP method, path, and query
// parameters of the request for audit logging purposes.
//
// Parameters:
//   - fName: The name of the function or component making the request
//   - r: The HTTP request being audited
//   - audit: A pointer to the AuditEntry to be updated
//   - action: The AuditAction to be recorded in the audit entry
func AuditRequest(fName string,
        r *http.Request, audit *AuditEntry, action AuditAction) <span class="cov0" title="0">{
        audit.Component = fName
        audit.Path = r.URL.Path
        audit.Resource = r.URL.RawQuery
        audit.Action = action
        Audit(*audit)
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package log

import (
        "log"
        "log/slog"
        "os"
        "strings"
        "sync"
)

var logger *slog.Logger
var loggerMutex sync.Mutex

// Log returns a thread-safe singleton instance of slog.Logger configured for
// JSON output. If the logger hasn't been initialized, it creates a new instance
// with the log level specified by the environment. Subsequent calls return the
// same logger instance.
func Log() *slog.Logger <span class="cov0" title="0">{
        loggerMutex.Lock()
        defer loggerMutex.Unlock()

        if logger != nil </span><span class="cov0" title="0">{
                return logger
        }</span>

        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{
                Level: Level(),
        }

        handler := slog.NewJSONHandler(os.Stdout, opts)

        logger = slog.New(handler)
        return logger</span>
}

// Fatal logs a message at Fatal level and then calls os.Exit(1).
func Fatal(msg string) <span class="cov0" title="0">{
        log.Fatal(msg)
}</span>

// FatalF logs a formatted message at Fatal level and then calls os.Exit(1).
// It follows the printf formatting rules.
func FatalF(format string, args ...any) <span class="cov0" title="0">{
        log.Fatalf(format, args...)
}</span>

// FatalLn logs a message at Fatal level with a line feed and then calls
// os.Exit(1).
func FatalLn(args ...any) <span class="cov0" title="0">{
        log.Fatalln(args...)
}</span>

// Level returns the logging level for the SPIKE components.
//
// It reads from the SPIKE_SYSTEM_LOG_LEVEL environment variable and
// converts it to the corresponding slog.Level value.
// Valid values (case-insensitive) are:
//   - "DEBUG": returns slog.LevelDebug
//   - "INFO": returns slog.LevelInfo
//   - "WARN": returns slog.LevelWarn
//   - "ERROR": returns slog.LevelError
//
// If the environment variable is not set or contains an invalid value,
// it returns the default level slog.LevelWarn.
func Level() slog.Level <span class="cov0" title="0">{
        level := os.Getenv("SPIKE_SYSTEM_LOG_LEVEL")
        level = strings.ToUpper(level)

        switch level </span>{
        case "DEBUG":<span class="cov0" title="0">
                return slog.LevelDebug</span> // -4
        case "INFO":<span class="cov0" title="0">
                return slog.LevelInfo</span> // 0
        case "WARN":<span class="cov0" title="0">
                return slog.LevelWarn</span> // 4
        case "ERROR":<span class="cov0" title="0">
                return slog.LevelError</span> // 8
        default:<span class="cov0" title="0">
                return slog.LevelWarn</span> // 4
        }
}
</pre>
		
		<pre class="file" id="file107" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/url"

        "github.com/spiffe/spike/internal/log"
)

// RouteFactory creates HTTP route handlers for API endpoints using a generic
// switching function. It enforces POST-only methods per ADR-0012 and logs
// route creation details.
//
// Type Parameters:
//   - ApiAction: Type representing the API action to be handled
//
// Parameters:
//   - p: API URL for the route
//   - a: API action instance
//   - m: HTTP method
//   - switchyard: Function that returns an appropriate handler based on
//     action and URL
//
// Returns:
//   - Handler: Route handler function or Fallback for non-POST methods
func RouteFactory[ApiAction any](p url.ApiUrl, a ApiAction, m string,
        switchyard func(a ApiAction, p url.ApiUrl) Handler) Handler <span class="cov0" title="0">{
        log.Log().Info("route.factory", "path", p, "action", a, "method", m)

        // We only accept POST requests -- See ADR-0012.
        if m != http.MethodPost </span><span class="cov0" title="0">{
                return Fallback
        }</span>

        <span class="cov0" title="0">return switchyard(a, p)</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package net

import (
        "net/http"
        "time"

        "github.com/spiffe/spike-sdk-go/crypto"

        "github.com/spiffe/spike/internal/log"
)

// Handler is a function type that processes HTTP requests with audit
// logging support.
type Handler func(http.ResponseWriter, *http.Request, *log.AuditEntry) error

// HandleRoute wraps an HTTP handler with audit logging functionality.
// It creates and manages audit log entries for the request lifecycle,
// including
// - Generating unique trail IDs
// - Recording timestamps and durations
// - Tracking request status (created, success, error)
// - Capturing error information
//
// The wrapped handler is mounted at the root path ("/") and automatically
// logs entry and exit audit events for all requests.
//
// Parameters:
//   - h: Handler function to wrap with audit logging
func HandleRoute(h Handler) <span class="cov0" title="0">{
        http.HandleFunc("/", func(
                writer http.ResponseWriter, request *http.Request,
        ) </span><span class="cov0" title="0">{
                now := time.Now()
                entry := log.AuditEntry{
                        TrailId:   crypto.Id(),
                        Timestamp: now,
                        UserId:    "",
                        Action:    log.AuditEnter,
                        Path:      request.URL.Path,
                        Resource:  "",
                        SessionID: "",
                        State:     log.AuditEntryCreated,
                }
                log.Audit(entry)

                err := h(writer, request, &amp;entry)
                if err == nil </span><span class="cov0" title="0">{
                        entry.Action = log.AuditExit
                        entry.State = log.AuditSuccess
                }</span> else<span class="cov0" title="0"> {
                        entry.Action = log.AuditExit
                        entry.State = log.AuditErrored
                        entry.Err = err.Error()
                }</span>

                <span class="cov0" title="0">entry.Duration = time.Since(now)
                log.Audit(entry)</span>
        })
}
</pre>
		
		<pre class="file" id="file109" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "bytes"
        "errors"
        "io"
        "net/http"

        apiErr "github.com/spiffe/spike-sdk-go/api/errors"

        "github.com/spiffe/spike/internal/log"
)

func body(r *http.Response) (bod []byte, err error) <span class="cov0" title="0">{
        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return body, err</span>
}

// Post performs an HTTP POST request with a JSON payload and returns the
// response body. It handles the common cases of connection errors, non-200
// status codes, and proper response body handling.
//
// Parameters:
//   - client: An *http.Client used to make the request, typically
//     configured with TLS settings.
//   - path: The URL path to send the POST request to.
//   - mr: A byte slice containing the marshaled JSON request body.
//
// Returns:
//   - []byte: The response body if the request is successful.
//   - error: An error if any of the following occur:
//   - Connection failure during POST request
//   - Non-200 status code in response
//   - Failure to read response body
//   - Failure to close response body
//
// The function ensures proper cleanup by always attempting to close the
// response body, even if an error occurs during reading. Any error from closing
// the body is joined with any existing error using errors.Join.
//
// Example:
//
//        client := &amp;http.Client{}
//        data := []byte(`{"key": "value"}`)
//        response, err := Post(client, "https://api.example.com/endpoint", data)
//        if err != nil {
//            log.Fatalf("failed to post: %v", err)
//        }
func Post(client *http.Client, path string, mr []byte) ([]byte, error) <span class="cov0" title="0">{
        log.Log().Info("post", "path", path)

        // Create the request while preserving the mTLS client
        req, err := http.NewRequest("POST", path, bytes.NewBuffer(mr))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(
                        errors.New("post: Failed to create request"),
                        err,
                )
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // Use the existing mTLS client to make the request
        r, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, errors.Join(
                        apiErr.ErrPeerConnection,
                        err,
                )
        }</span>

        <span class="cov0" title="0">if r.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                if r.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return []byte{}, apiErr.ErrNotFound
                }</span>

                <span class="cov0" title="0">if r.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return []byte{}, apiErr.ErrUnauthorized
                }</span>

                <span class="cov0" title="0">return []byte{}, apiErr.ErrPeerConnection</span>
        }

        <span class="cov0" title="0">b, err := body(r)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, errors.Join(
                        apiErr.ErrReadingResponseBody,
                        err,
                )
        }</span>

        <span class="cov0" title="0">defer func(b io.ReadCloser) </span><span class="cov0" title="0">{
                if b == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">err = errors.Join(err, b.Close())</span>
        }(r.Body)

        <span class="cov0" title="0">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/spiffe/spike-sdk-go/net"

        "github.com/spiffe/spike/internal/log"
)

// ReadRequestBody reads the entire request body from an HTTP request.
// It returns the body as a byte slice if successful. If there is an error
// reading the body or if the body is nil, it writes a 400 Bad Request status
// to the response writer and returns an empty byte slice. Any errors
// encountered are logged.
func ReadRequestBody(w http.ResponseWriter, r *http.Request) []byte <span class="cov0" title="0">{
        body, err := net.RequestBody(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Info("readRequestBody",
                        "msg", "Problem reading request body",
                        "err", err.Error())

                w.WriteHeader(http.StatusBadRequest)
                _, err := io.WriteString(w, "")
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Info("readRequestBody",
                                "msg", "Problem writing response",
                                "err", err.Error())
                }</span>

                <span class="cov0" title="0">return []byte{}</span>
        }

        <span class="cov0" title="0">if body == nil </span><span class="cov0" title="0">{
                log.Log().Info("readRequestBody", "msg", "No request body.")

                w.WriteHeader(http.StatusBadRequest)
                _, err := io.WriteString(w, "")
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Info("readRequestBody",
                                "msg", "Problem writing response",
                                "err", err.Error())
                }</span>
                <span class="cov0" title="0">return []byte{}</span>
        }

        <span class="cov0" title="0">return body</span>
}

// HandleRequestError handles HTTP request errors by writing a 400 Bad Request
// status to the response writer. If err is nil, it returns nil. Otherwise, it
// writes the error status and returns a joined error containing both the
// original error and any error encountered while writing the response.
func HandleRequestError(w http.ResponseWriter, err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusBadRequest)
        _, writeErr := io.WriteString(w, "")

        return errors.Join(err, writeErr)</span>
}

// HandleRequest unmarshals a JSON request body into a typed request struct.
//
// This is a generic function that handles the common pattern of unmarshaling
// and validating incoming JSON requests. If unmarshaling fails, it sends the
// provided error response to the client with a 400 Bad Request status.
//
// Type Parameters:
//   - Req: The request type to unmarshal into
//   - Res: The response type for error cases
//
// Parameters:
//   - requestBody: []byte - The raw JSON request body to unmarshal
//   - w: http.ResponseWriter - The response writer for error handling
//   - errorResponse: Res - A response object to send if unmarshaling fails
//
// Returns:
//   - *Req - A pointer to the unmarshaled request struct, or nil if
//     unmarshaling failed
//
// The function handles all error logging and response writing for the error
// case. Callers should check if the returned pointer is nil before proceeding.
func HandleRequest[Req any, Res any](
        requestBody []byte,
        w http.ResponseWriter,
        errorResponse Res,
) *Req <span class="cov0" title="0">{
        var request Req

        if err := HandleRequestError(
                w, json.Unmarshal(requestBody, &amp;request),
        ); err != nil </span><span class="cov0" title="0">{
                log.Log().Error("HandleRequest",
                        "msg", "Problem unmarshalling request",
                        "err", err.Error())

                responseBody := MarshalBody(errorResponse, w)
                if responseBody == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">Respond(http.StatusBadRequest, responseBody, w)
                return nil</span>
        }

        <span class="cov0" title="0">return &amp;request</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">//    \\ SPIKE: Secure your secrets with SPIFFE. — https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/spiffe/spike-sdk-go/api/entity/data"
        "github.com/spiffe/spike-sdk-go/api/entity/v1/reqres"

        "github.com/spiffe/spike/internal/log"
)

// MarshalBody serializes a response object to JSON and handles error cases.
//
// This function attempts to marshal the provided response object to JSON bytes.
// If marshaling fails, it sends a 500 Internal Server Error response to the
// client and returns nil. The function handles all error logging and response
// writing for the error case.
//
// Parameters:
//   - res: any - The response object to marshal to JSON
//   - w: http.ResponseWriter - The response writer for error handling
//
// Returns:
//   - []byte - The marshaled JSON bytes, or nil if marshaling failed
func MarshalBody(res any, w http.ResponseWriter) []byte <span class="cov0" title="0">{
        body, err := json.Marshal(res)

        if err != nil </span><span class="cov0" title="0">{
                log.Log().Error("marshalBody",
                        "msg", "Problem generating response",
                        "err", err.Error())

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)

                _, err = w.Write([]byte(`{"error":"internal server error"}`))
                if err != nil </span><span class="cov0" title="0">{
                        log.Log().Error("marshalBody",
                                "msg", "Problem writing response",
                                "err", err.Error())
                        return nil
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return body</span>
}

// Respond writes a JSON response with the specified status code and body.
//
// This function sets the Content-Type header to application/json, adds cache
// invalidation headers (Cache-Control, Pragma, Expires), writes the provided 
// status code, and sends the response body. Any errors during writing are 
// logged but not returned to the caller.
//
// Parameters:
//   - statusCode: int - The HTTP status code to send
//   - body: []byte - The pre-marshaled JSON response body
//   - w: http.ResponseWriter - The response writer to use
func Respond(statusCode int, body []byte, w http.ResponseWriter) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")

        // Add cache invalidation headers
        w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, private")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")

        w.WriteHeader(statusCode)

        _, err := w.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Log().Error("routeKeep",
                        "msg", "Problem writing response",
                        "err", err.Error())
        }</span>
}

// Fallback handles requests to undefined routes by returning a 400 Bad Request.
//
// This function serves as a catch-all handler for undefined routes, logging the
// request details and returning a standardized error response. It uses
// MarshalBody to generate the response and handles any errors during response
// writing.
//
// Parameters:
//   - w: http.ResponseWriter - The response writer
//   - r: *http.Request - The incoming request
//
// The response always includes:
//   - Status: 400 Bad Request
//   - Content-Type: application/json
//   - Body: JSON object with an error field
func Fallback(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        log.Log().Info("fallback",
                "method", r.Method,
                "path", r.URL.Path,
                "query", r.URL.RawQuery)
        audit.Action = log.AuditFallback

        body := MarshalBody(reqres.FallbackResponse{Err: data.ErrBadInput}, w)
        if body == nil </span><span class="cov0" title="0">{
                return errors.New("failed to marshal response body")
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)

        if _, err := w.Write(body); err != nil </span><span class="cov0" title="0">{
                log.Log().Error("routeFallback",
                        "msg", "Problem writing response",
                        "err", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NotReady handles requests when the system has not initialized its backing
// store with a root key by returning a 400 Bad Request.
//
// This function uses MarshalBody to generate the response and handles any
// errors during response writing.
//
// Parameters:
//   - w: http.ResponseWriter - The response writer
//   - r: *http.Request - The incoming request
//   - audit: *log.AuditEntry - The audit log entry for this request
//
// The response always includes:
//   - Status: 400 Bad Request
//   - Content-Type: application/json
//   - Body: JSON object with an error field containing ErrLowEntropy
//
// Returns:
//   - error: Returns nil on success, or an error if response marshaling or
//     writing fails
func NotReady(
        w http.ResponseWriter, r *http.Request, audit *log.AuditEntry,
) error <span class="cov0" title="0">{
        log.Log().Info("not-ready",
                "method", r.Method,
                "path", r.URL.Path,
                "query", r.URL.RawQuery)
        audit.Action = log.AuditBlocked

        body := MarshalBody(reqres.FallbackResponse{Err: data.ErrNotReady}, w)
        if body == nil </span><span class="cov0" title="0">{
                return errors.New("failed to marshal response body")
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusServiceUnavailable)

        if _, err := w.Write(body); err != nil </span><span class="cov0" title="0">{
                log.Log().Error("routeNotReady",
                        "msg", "Problem writing response",
                        "err", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
