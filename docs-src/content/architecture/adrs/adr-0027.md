+++
#    \\ SPIKE: Secure your secrets with SPIFFE. â€” https://spike.ist/
#  \\\\\ Copyright 2024-present SPIKE contributors.
# \\\\\\\ SPDX-License-Identifier: Apache-2.0

title = "ADR-0027: Separate Audit Logs from Operational Logs"
weight = 10027
sort_by = "weight"
+++

# ADR-0027: Separate Audit Logs from Operational Logs

- **Status**: proposed
- **Date**: 2025-10-12
- **Tags**: Security, Compliance, Observability, Kubernetes

## Context and Problem Statement

Currently, SPIKE sends audit logs and operational logs to stdout without 
differentiation. This creates challenges for:

* Compliance requirements that mandate immutable audit trails with specific 
  retention policies
* Security teams needing to route audit events to SIEM systems
* Different access controls between audit and operational logs
* Performance optimization as audit logs have different characteristics 
  than operational logs

We need to determine the most effective way to separate audit logs from 
operational logs while maintaining simplicity and Kubernetes-native practices.

## Decision Drivers

* **Compliance requirements**: Audit logs often need years of retention 
  versus days/weeks for operational logs
* **Security isolation**: Audit logs require stricter access controls and 
  tamper-evident storage
* **Operational simplicity**: Solution should work seamlessly in Kubernetes 
  environments
* **Performance considerations**: Different log volumes and processing 
  requirements
* **Integration flexibility**: Easy routing to different backends 
  (SIEM versus observability stacks)

## Considered Options

1. **Use stderr for audit logs** (stdout for operational)
2. **Structured logging with type field** (both to stdout)
3. **Dedicated audit sidecar pattern**
4. **Direct audit system integration** (separate API calls)
5. **Pluggable audit devices** (Vault-style architecture)

## Decision

Implement a **two-phase approach**:

**Phase 1 (Immediate)**: Use stderr for audit logs while keeping operational 
logs on stdout, with structured JSON format and clear prefixes.

**Phase 2 (Future)**: Evolve to pluggable audit devices.

## Rationale

### Phase 1 Justification
* **Immediate value**: Can be implemented quickly with minimal changes
* **Kubernetes-native**: Works with existing log collectors (Fluentd/Fluent Bit)
* **Clear separation**: File descriptors provide OS-level isolation

### Phase 2 Justification
* **Enterprise readiness**: Matches proven patterns for log collection and 
  routing
* **Flexibility**: Supports file, socket, syslog, and custom backends
* **Guaranteed delivery**: Can implement blocking behavior when audit fails
* **Compliance**: Better suits enterprise audit requirements

### Why Not Other Options

- **Structured logging only**: Doesn't provide strong enough separation for 
  compliance
- **Sidecar pattern**: Adds complexity without clear benefits over stderr 
  approach
- **Direct integration only**: Less flexible, harder to adapt to different
  environments

## Implementation Details

### Phase 1 Implementation

```go
// Audit event structure
type AuditEvent struct {
    Version   string                `json:"v"`
    Timestamp time.Time             `json:"ts"`
    EventID   string                `json:"id"`
    Type      string                `json:"type"` // access|modify|delete|auth
    Principal string                `json:"principal"`
    SPIFFEID  string                `json:"spiffe_id"`
    Resource  string                `json:"resource"`
    Action    string                `json:"action"`
    Outcome   string                `json:"outcome"` // success|failure|error
    Details   map[string]interface{} `json:"details,omitempty"`
    SourceIP  string                `json:"src_ip,omitempty"`
    Signature string                `json:"sig,omitempty"` // HMAC for tamper detection
}

// Simple audit logger for Phase 1
func LogAudit(event AuditEvent) {
    fmt.Fprintf(os.Stderr, "AUDIT:%s\n", event.ToJSON())
}

// Operational logs continue to stdout
```

### Phase 2 Architecture

```go
// Pluggable audit device interface (future)
type AuditDevice interface {
    Write(event AuditEvent) error
    Close() error
}

type AuditManager struct {
    devices  []AuditDevice
    blocking bool // If true, operations fail when audit fails
    hmacKey  []byte
}

// Implementations
type FileAuditDevice struct { /* ... */ }
type SocketAuditDevice struct { /* ... */ }
type SyslogAuditDevice struct { /* ... */ }
```

### Sample Kubernetes Configuration

```yaml
# Fluentd/Fluent Bit routing based on stream
<source>
  @type tail
  path /var/log/containers/*.log
  <parse>
    @type multi_format
    <pattern>
      format regexp
      expression /^(?<time>.+) (?<stream>stdout|stderr) (?<log>.*)$/
    </pattern>
  </parse>
</source>

<filter **>
  @type record_transformer
  <record>
    log_type ${tag_parts[0] == 'stderr' ? 'audit' : 'operational'}
  </record>
</filter>

<match audit.**>
  @type elasticsearch
  index_name audit-logs
  # Immutable index settings
</match>
```

## Consequences

### Positive

* **Immediate compliance improvement**: Clear audit trail separation
* **Simple migration path**: Phase 1 requires minimal code changes
* **Kubernetes-friendly**: Works with existing tooling
* **Future-proof**: Phase 2 provides enterprise-grade capabilities
* **SPIFFE integration**: Can include SPIFFE ID in audit events
* **Tamper detection**: Optional HMAC signatures on audit events

### Negative

* **Two-phase complexity**: Requires planning for migration
* **Stderr convention**: Some tools expect only errors on stderr
* **Configuration overhead**: More complex log routing rules
* **Potential performance impact**: Audit devices could block operations

## References

* SPIFFE Audit Considerations: https://spiffe.io/docs/latest/planning/audit/
* Kubernetes Logging Architecture: https://kubernetes.io/docs/concepts/cluster-administration/logging/
