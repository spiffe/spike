//    \\ SPIKE: Secure your secrets with SPIFFE. â€” https://spike.ist/
//  \\\\\ Copyright 2024-present SPIKE contributors.
// \\\\\\\ SPDX-License-Identifier: Apache-2.0

package net

import (
	"context"
	"time"

	"github.com/cloudflare/circl/secretsharing"
	spike "github.com/spiffe/spike-sdk-go/api"
	"github.com/spiffe/spike-sdk-go/config/env"
	sdkErrors "github.com/spiffe/spike-sdk-go/errors"
	"github.com/spiffe/spike-sdk-go/log"
	"github.com/spiffe/spike-sdk-go/retry"

	"github.com/spiffe/spike/app/bootstrap/internal/state"
)

// broadcastToKeeper sends a root key share to a single SPIKE Keeper instance.
// It creates a timeout context for the operation and retries with exponential
// backoff until success or the maximum retry attempts are exhausted.
//
// Parameters:
//   - ctx: Parent context for cancellation
//   - api: SPIKE API client for communicating with keepers
//   - rs: Root key shares generated by Shamir secret sharing
//   - keeperID: Identifier of the target keeper
//   - keeperURL: URL of the target keeper
//   - timeout: Timeout duration for the operation
//   - maxRetries: Maximum number of retry attempts
//
// Returns:
//   - *sdkErrors.SDKError if the keeper cannot be reached, nil on success
func broadcastToKeeper(
	ctx context.Context, api *spike.API,
	rs []secretsharing.Share, keeperID, keeperURL string,
	timeout time.Duration, maxRetries int,
) *sdkErrors.SDKError {
	const fName = "broadcastToKeeper"

	keeperShare := state.KeeperShare(rs, keeperID)

	// A zero timeout means no timeout (infinite). We must handle this explicitly
	// because context.WithTimeout(ctx, 0) creates an already-expired context,
	// not an infinite one.
	keeperCtx := ctx
	var cancel context.CancelFunc = func() {}
	if timeout > 0 {
		keeperCtx, cancel = context.WithTimeout(ctx, timeout)
	}
	defer cancel()

	_, err := retry.WithMaxAttempts(keeperCtx, maxRetries,
		func() (bool, *sdkErrors.SDKError) {
			log.Info(fName,
				"message", "sending shard to keeper",
				"keeper_id", keeperID,
				"keeper_url", keeperURL,
			)

			if contributeErr := api.Contribute(
				keeperCtx, keeperShare, keeperID,
			); contributeErr != nil {
				warnErr := sdkErrors.ErrAPIPostFailed.Wrap(contributeErr)
				warnErr.Msg = "failed to send shard: will retry"
				log.WarnErr(fName, *warnErr)
				return false, warnErr
			}

			return true, nil
		},
		retry.WithBackOffOptions(
			retry.WithInitialInterval(env.BootstrapKeeperRetryInitialIntervalVal()),
			retry.WithMaxInterval(env.BootstrapKeeperRetryMaxIntervalVal()),
		),
	)

	return err
}
